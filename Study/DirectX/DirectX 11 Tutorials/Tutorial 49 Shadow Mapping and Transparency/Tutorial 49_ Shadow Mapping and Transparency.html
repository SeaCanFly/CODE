
<!-- saved from url=(0039)http://www.rastertek.com/dx11tut49.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Tutorial 49: Shadow Mapping and Transparency</title><style>#cVim-command-bar, #cVim-command-bar-mode, #cVim-command-bar-input, #cVim-command-bar-search-results,
.cVim-completion-item, .cVim-completion-item .cVim-full, .cVim-completion-item .cVim-left,
.cVim-completion-item .cVim-right {
  font-family: Helvetica, Helvetica Neue, Neue, sans-serif, monospace, Arial;
  font-size: 10pt !important;
  -webkit-font-smoothing: antialiased !important;
}

#cVim-command-bar {
  position: fixed;
  z-index: 2147483646;
  background-color: #1b1d1e;
  color: #bbb;
  display: none;
  box-sizing: content-box;
  box-shadow: 0 3px 3px rgba(0,0,0,0.4);
  left: 0;
  width: 100%;
  height: 20px;
}

#cVim-command-bar-mode {
  display: inline-block;
  vertical-align: middle;
  box-sizing: border-box;
  padding-left: 2px;
  height: 100%;
  width: 10px;
  padding-top: 2px;
  color: #888;
}

#cVim-command-bar-input {
  background-color: #1b1d1e;
  color: #bbb;
  height: 100%;
  right: 0;
  top: 0;
  width: calc(100% - 10px);
  position: absolute;
}

#cVim-command-bar-search-results {
  position: fixed;
  width: 100%;
  overflow: hidden;
  z-index: 2147483647;
  left: 0;
  box-shadow: 0 3px 3px rgba(0,0,0,0.4);
  background-color: #1c1c1c;
}

.cVim-completion-item, .cVim-completion-item .cVim-full, .cVim-completion-item .cVim-left, .cVim-completion-item .cVim-right {
  text-overflow: ellipsis;
  padding: 1px;
  display: inline-block;
  box-sizing: border-box;
  vertical-align: middle;
  overflow: hidden;
  white-space: nowrap;
}

.cVim-completion-item:nth-child(even) {
  background-color: #1f1f1f;
}

.cVim-completion-item {
  width: 100%; left: 0;
  color: #bcbcbc;
}

.cVim-completion-item[active] {
  width: 100%; left: 0;
  color: #1b1d1e;
  background-color: #f1f1f1;
}

.cVim-completion-item[active] span {
  color: #1b1d1e;
}

.cVim-completion-item .cVim-left {
  color: #fff;
  width: 37%;
}

.cVim-completion-item .cVim-right {
  font-style: italic;
  color: #888;
  width: 57%;
}


#cVim-link-container, .cVim-link-hint,
#cVim-hud, #cVim-status-bar {
  font-family: Helvetica, Helvetica Neue, Neue, sans-serif, monospace, Arial;
  font-size: 10pt !important;
  -webkit-font-smoothing: antialiased !important;
}

#cVim-link-container {
  position: absolute;
  pointer-events: none;
  width: 100%; left: 0;
  height: 100%; top: 0;
  z-index: 2147483647;
}

.cVim-link-hint {
  position: absolute;
  color: #302505 !important;
  background-color: #ffd76e !important;
  border-radius: 2px !important;
  padding: 2px !important;
  font-size: 8pt !important;
  font-weight: 500 !important;
  text-transform: uppercase !important;
  border: 1px solid #ad810c;
  display: inline-block !important;
  vertical-align: middle !important;
  text-align: center !important;
  box-shadow: 2px 2px 1px rgba(0,0,0,0.25) !important;
}

.cVim-link-hint_match {
  color: #777;
  text-transform: uppercase !important;
}


#cVim-hud {
  background-color: rgba(28,28,28,0.9);
  position: fixed !important;
  transition: right 0.2s ease-out;
  z-index: 24724289;
}

#cVim-hud span {
  padding: 2px;
  padding-left: 4px;
  padding-right: 4px;
  color: #8f8f8f;
  font-size: 10pt;
}

#cVim-frames-outline {
  position: fixed;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  right: 0;
  z-index: 9999999999;
  box-sizing: border-box;
  border: 3px solid yellow;
}
</style><link type="text/css" rel="stylesheet" href="chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/content.css"></head>
<body text="#FFFFFF" bgcolor="#000000" style="width:1000px">

<p align="center"><font face="Arial" size="4" color="#FFFFFF"><b>
Tutorial 49: Shadow Mapping and Transparency
</b></font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic1001.gif" width="800" height="1"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
In this tutorial we will go over how to shadow map objects that use textures with alpha transparency.
The code will be written using DirectX 11 and HLSL.
This tutorial will build on the code from the previous shadow mapping tutorials.
We will start with the classic example of a tree that uses quads for leaves with a transparent leaf texture.
</font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic0291.gif" width="400" height="400"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
If we turn blending off you can see the quads that form the leaves.
</font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic0292.gif" width="400" height="400"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The texture used in this example is the following:
</font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic0293.gif" width="256" height="256"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Now this causes an issue with shadow mapping because with the current depth shader it would only have access to the quad geometry
and would not have access to the transparency texture.
So this would cause quads to be drawn as shadows instead of the leaves inside the transparency texture.
</font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic0295.gif" width="400" height="323"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
To deal with this issue we will need a second depth shader to render transparent objects,
it will be the same as the regular depth shader except that we will provide it the transparency texture and discard pixels that are below a certain alpha value.
With this in place we will be able to render shadow maps that use transparency textures.
</font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic0294.gif" width="400" height="360"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We will start the code section by looking at the transparent depth shader.
</font></p>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparentdepth.vs</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparentdepth.vs
////////////////////////////////////////////////////////////////////////////////


/////////////
// GLOBALS //
/////////////
cbuffer MatrixBuffer
{
    matrix worldMatrix;
    matrix viewMatrix;
    matrix projectionMatrix;
};
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The structs now have a texture coordinate component.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">//////////////
// TYPEDEFS //
//////////////
struct VertexInputType
{
    float4 position : POSITION;</font><font face="arial" color="#aaaaff" size="2">
    float2 tex : TEXCOORD0;</font><font face="arial" color="#aaffaa" size="2">
};

struct PixelInputType
{
    float4 position : SV_POSITION;
    float4 depthPosition : TEXCOORD0;</font><font face="arial" color="#aaaaff" size="2">
    float2 tex : TEXCOORD1;</font><font face="arial" color="#aaffaa" size="2">
};


////////////////////////////////////////////////////////////////////////////////
// Vertex Shader
////////////////////////////////////////////////////////////////////////////////
PixelInputType TransparentDepthVertexShader(VertexInputType input)
{
    PixelInputType output;


    // Change the position vector to be 4 units for proper matrix calculations.
    input.position.w = 1.0f;

    // Calculate the position of the vertex against the world, view, and projection matrices.
    output.position = mul(input.position, worldMatrix);
    output.position = mul(output.position, viewMatrix);
    output.position = mul(output.position, projectionMatrix);

    // Store the position value in a second input value for depth value calculations.
    output.depthPosition = output.position;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The texture coordinates are now sent into the pixel shader.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">    // Store the texture coordinates for the pixel shader.
    output.tex = input.tex;</font><font face="arial" color="#aaffaa" size="2">

    return output;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparentdepth.ps</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparentdepth.ps
////////////////////////////////////////////////////////////////////////////////
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We have added a texture to the pixel shader.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">//////////////
// TEXTURES //
//////////////
Texture2D shaderTexture : register(t0);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We will also require a sampler to retrieve the texture data.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">///////////////////
// SAMPLE STATES //
///////////////////
SamplerState SampleType : register(s0);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The struct in the pixel shader also now has a texture coordinate component.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float4 depthPosition : TEXCOORD0;</font><font face="arial" color="#aaaaff" size="2">
    float2 tex : TEXCOORD1;</font><font face="arial" color="#aaffaa" size="2">
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TransparentDepthPixelShader(PixelInputType input) : SV_TARGET
{
	float depthValue;
	float4 color;</font><font face="arial" color="#aaaaff" size="2">
	float4 textureColor;</font><font face="arial" color="#aaffaa" size="2">
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We now sample the transparency texture and determine if the alpha value is above a certain value.
If it is above a certain value then this is an opaque pixel that should be part of the shadow.
If it is below that same value then we simply discard the pixel so it is not part of the shadow.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Sample the pixel color from the texture using the sampler at this texture coordinate location.
	textureColor = shaderTexture.Sample(SampleType, input.tex);

	// Test based on the alpha value of the texture.
	if(textureColor.a &gt; 0.8f)
	{
		// Get the depth value of the pixel by dividing the Z pixel depth by the homogeneous W coordinate.
		depthValue = input.depthPosition.z / input.depthPosition.w;
	}
	else
	{
		// Otherwise discard this pixel entirely.
		discard;
	}</font><font face="arial" color="#aaffaa" size="2">

	color = float4(depthValue, depthValue, depthValue, 1.0f);

	return color;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparentdepthshaderclass.h</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The TransparentDepthShaderClass is the same as the DepthShaderClass except that it handles texture data.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparentdepthshaderclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _TRANSPARENTDEPTHSHADERCLASS_H_
#define _TRANSPARENTDEPTHSHADERCLASS_H_


//////////////
// INCLUDES //
//////////////
#include &lt;d3d11.h&gt;
#include &lt;d3dx10math.h&gt;
#include &lt;d3dx11async.h&gt;
#include &lt;fstream&gt;
using namespace std;


////////////////////////////////////////////////////////////////////////////////
// Class name: TransparentDepthShaderClass
////////////////////////////////////////////////////////////////////////////////
class TransparentDepthShaderClass
{
private:
	struct MatrixBufferType
	{
		D3DXMATRIX world;
		D3DXMATRIX view;
		D3DXMATRIX projection;
	};

public:
	TransparentDepthShaderClass();
	TransparentDepthShaderClass(const TransparentDepthShaderClass&amp;);
	~TransparentDepthShaderClass();

	bool Initialize(ID3D11Device*, HWND);
	void Shutdown();</font><font face="arial" color="#aaaaff" size="2">
	bool Render(ID3D11DeviceContext*, int, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*);</font><font face="arial" color="#aaffaa" size="2">

private:
	bool InitializeShader(ID3D11Device*, HWND, WCHAR*, WCHAR*);
	void ShutdownShader();
	void OutputShaderErrorMessage(ID3D10Blob*, HWND, WCHAR*);</font><font face="arial" color="#aaaaff" size="2">

	bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*);</font><font face="arial" color="#aaffaa" size="2">
	void RenderShader(ID3D11DeviceContext*, int);

private:
	ID3D11VertexShader* m_vertexShader;
	ID3D11PixelShader* m_pixelShader;
	ID3D11InputLayout* m_layout;
	ID3D11Buffer* m_matrixBuffer;</font><font face="arial" color="#aaaaff" size="2">
	ID3D11SamplerState* m_sampleState;</font><font face="arial" color="#aaffaa" size="2">
};

#endif
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparentdepthshaderclass.cpp</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparentdepthshaderclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "transparentdepthshaderclass.h"


TransparentDepthShaderClass::TransparentDepthShaderClass()
{
	m_vertexShader = 0;
	m_pixelShader = 0;
	m_layout = 0;
	m_matrixBuffer = 0;</font><font face="arial" color="#aaaaff" size="2">
	m_sampleState = 0;</font><font face="arial" color="#aaffaa" size="2">
}


TransparentDepthShaderClass::TransparentDepthShaderClass(const TransparentDepthShaderClass&amp; other)
{
}


TransparentDepthShaderClass::~TransparentDepthShaderClass()
{
}


bool TransparentDepthShaderClass::Initialize(ID3D11Device* device, HWND hwnd)
{
	bool result;


	// Initialize the vertex and pixel shaders.</font><font face="arial" color="#aaaaff" size="2">
	result = InitializeShader(device, hwnd, L"../Engine/transparentdepth.vs", L"../Engine/transparentdepth.ps");</font><font face="arial" color="#aaffaa" size="2">
	if(!result)
	{
		return false;
	}

	return true;
}


void TransparentDepthShaderClass::Shutdown()
{
	// Shutdown the vertex and pixel shaders as well as the related objects.
	ShutdownShader();

	return;
}</font><font face="arial" color="#aaaaff" size="2">


bool TransparentDepthShaderClass::Render(ID3D11DeviceContext* deviceContext, int indexCount, D3DXMATRIX worldMatrix, D3DXMATRIX viewMatrix, D3DXMATRIX projectionMatrix, 
					 ID3D11ShaderResourceView* texture)</font><font face="arial" color="#aaffaa" size="2">
{
	bool result;


	// Set the shader parameters that it will use for rendering.</font><font face="arial" color="#aaaaff" size="2">
	result = SetShaderParameters(deviceContext, worldMatrix, viewMatrix, projectionMatrix, texture);</font><font face="arial" color="#aaffaa" size="2">
	if(!result)
	{
		return false;
	}

	// Now render the prepared buffers with the shader.
	RenderShader(deviceContext, indexCount);

	return true;
}


bool TransparentDepthShaderClass::InitializeShader(ID3D11Device* device, HWND hwnd, WCHAR* vsFilename, WCHAR* psFilename)
{
	HRESULT result;
	ID3D10Blob* errorMessage;
	ID3D10Blob* vertexShaderBuffer;
	ID3D10Blob* pixelShaderBuffer;</font><font face="arial" color="#aaaaff" size="2">
	D3D11_INPUT_ELEMENT_DESC polygonLayout[2];</font><font face="arial" color="#aaffaa" size="2">
	unsigned int numElements;
	D3D11_BUFFER_DESC matrixBufferDesc;</font><font face="arial" color="#aaaaff" size="2">
	D3D11_SAMPLER_DESC samplerDesc;</font><font face="arial" color="#aaffaa" size="2">


	// Initialize the pointers this function will use to null.
	errorMessage = 0;
	vertexShaderBuffer = 0;
	pixelShaderBuffer = 0;

	// Compile the vertex shader code.</font><font face="arial" color="#aaaaff" size="2">
	result = D3DX11CompileFromFile(vsFilename, NULL, NULL, "TransparentDepthVertexShader", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL, 
				       &amp;vertexShaderBuffer, &amp;errorMessage, NULL);</font><font face="arial" color="#aaffaa" size="2">
	if(FAILED(result))
	{
		// If the shader failed to compile it should have writen something to the error message.
		if(errorMessage)
		{
			OutputShaderErrorMessage(errorMessage, hwnd, vsFilename);
		}
		// If there was nothing in the error message then it simply could not find the shader file itself.
		else
		{
			MessageBox(hwnd, vsFilename, L"Missing Shader File", MB_OK);
		}

		return false;
	}

	// Compile the pixel shader code.</font><font face="arial" color="#aaaaff" size="2">
	result = D3DX11CompileFromFile(psFilename, NULL, NULL, "TransparentDepthPixelShader", "ps_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL, 
				       &amp;pixelShaderBuffer, &amp;errorMessage, NULL);</font><font face="arial" color="#aaffaa" size="2">
	if(FAILED(result))
	{
		// If the shader failed to compile it should have writen something to the error message.
		if(errorMessage)
		{
			OutputShaderErrorMessage(errorMessage, hwnd, psFilename);
		}
		// If there was nothing in the error message then it simply could not find the file itself.
		else
		{
			MessageBox(hwnd, psFilename, L"Missing Shader File", MB_OK);
		}

		return false;
	}

	// Create the vertex shader from the buffer.
	result = device-&gt;CreateVertexShader(vertexShaderBuffer-&gt;GetBufferPointer(), vertexShaderBuffer-&gt;GetBufferSize(), NULL, &amp;m_vertexShader);
	if(FAILED(result))
	{
		return false;
	}

	// Create the pixel shader from the buffer.
	result = device-&gt;CreatePixelShader(pixelShaderBuffer-&gt;GetBufferPointer(), pixelShaderBuffer-&gt;GetBufferSize(), NULL, &amp;m_pixelShader);
	if(FAILED(result))
	{
		return false;
	}

	// Create the vertex input layout description.
	polygonLayout[0].SemanticName = "POSITION";
	polygonLayout[0].SemanticIndex = 0;
	polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	polygonLayout[0].InputSlot = 0;
	polygonLayout[0].AlignedByteOffset = 0;
	polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[0].InstanceDataStepRate = 0;</font><font face="arial" color="#aaaaff" size="2">

	polygonLayout[1].SemanticName = "TEXCOORD";
	polygonLayout[1].SemanticIndex = 0;
	polygonLayout[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	polygonLayout[1].InputSlot = 0;
	polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[1].InstanceDataStepRate = 0;</font><font face="arial" color="#aaffaa" size="2">

	// Get a count of the elements in the layout.
	numElements = sizeof(polygonLayout) / sizeof(polygonLayout[0]);

	// Create the vertex input layout.
	result = device-&gt;CreateInputLayout(polygonLayout, numElements, vertexShaderBuffer-&gt;GetBufferPointer(), vertexShaderBuffer-&gt;GetBufferSize(), &amp;m_layout);
	if(FAILED(result))
	{
		return false;
	}

	// Release the vertex shader buffer and pixel shader buffer since they are no longer needed.
	vertexShaderBuffer-&gt;Release();
	vertexShaderBuffer = 0;

	pixelShaderBuffer-&gt;Release();
	pixelShaderBuffer = 0;

	// Setup the description of the dynamic matrix constant buffer that is in the vertex shader.
	matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	matrixBufferDesc.ByteWidth = sizeof(MatrixBufferType);
	matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	matrixBufferDesc.MiscFlags = 0;
	matrixBufferDesc.StructureByteStride = 0;

	// Create the constant buffer pointer so we can access the vertex shader constant buffer from within this class.
	result = device-&gt;CreateBuffer(&amp;matrixBufferDesc, NULL, &amp;m_matrixBuffer);
	if(FAILED(result))
	{
		return false;
	}</font><font face="arial" color="#aaaaff" size="2">

	// Create a texture sampler state description.
	samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.MipLODBias = 0.0f;
	samplerDesc.MaxAnisotropy = 1;
	samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
	samplerDesc.BorderColor[0] = 0;
	samplerDesc.BorderColor[1] = 0;
	samplerDesc.BorderColor[2] = 0;
	samplerDesc.BorderColor[3] = 0;
	samplerDesc.MinLOD = 0;
	samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;

	// Create the texture sampler state.
	result = device-&gt;CreateSamplerState(&amp;samplerDesc, &amp;m_sampleState);
	if(FAILED(result))
	{
		return false;
	}</font><font face="arial" color="#aaffaa" size="2">

	return true;
}


void TransparentDepthShaderClass::ShutdownShader()
{</font><font face="arial" color="#aaaaff" size="2">
	// Release the sampler state.
	if(m_sampleState)
	{
		m_sampleState-&gt;Release();
		m_sampleState = 0;
	}</font><font face="arial" color="#aaffaa" size="2">

	// Release the matrix constant buffer.
	if(m_matrixBuffer)
	{
		m_matrixBuffer-&gt;Release();
		m_matrixBuffer = 0;
	}

	// Release the layout.
	if(m_layout)
	{
		m_layout-&gt;Release();
		m_layout = 0;
	}

	// Release the pixel shader.
	if(m_pixelShader)
	{
		m_pixelShader-&gt;Release();
		m_pixelShader = 0;
	}

	// Release the vertex shader.
	if(m_vertexShader)
	{
		m_vertexShader-&gt;Release();
		m_vertexShader = 0;
	}

	return;
}


void TransparentDepthShaderClass::OutputShaderErrorMessage(ID3D10Blob* errorMessage, HWND hwnd, WCHAR* shaderFilename)
{
	char* compileErrors;
	unsigned long bufferSize, i;
	ofstream fout;


	// Get a pointer to the error message text buffer.
	compileErrors = (char*)(errorMessage-&gt;GetBufferPointer());

	// Get the length of the message.
	bufferSize = errorMessage-&gt;GetBufferSize();

	// Open a file to write the error message to.
	fout.open("shader-error.txt");

	// Write out the error message.
	for(i=0; i&lt;bufferSize; i++)
	{
		fout &lt;&lt; compileErrors[i];
	}

	// Close the file.
	fout.close();

	// Release the error message.
	errorMessage-&gt;Release();
	errorMessage = 0;

	// Pop a message up on the screen to notify the user to check the text file for compile errors.
	MessageBox(hwnd, L"Error compiling shader.  Check shader-error.txt for message.", shaderFilename, MB_OK);

	return;
}</font><font face="arial" color="#aaaaff" size="2">


bool TransparentDepthShaderClass::SetShaderParameters(ID3D11DeviceContext* deviceContext, D3DXMATRIX worldMatrix, D3DXMATRIX viewMatrix, D3DXMATRIX projectionMatrix, 
						      ID3D11ShaderResourceView* texture)</font><font face="arial" color="#aaffaa" size="2">
{
	HRESULT result;
	D3D11_MAPPED_SUBRESOURCE mappedResource;
	unsigned int bufferNumber;
	MatrixBufferType* dataPtr;


	// Transpose the matrices to prepare them for the shader.
	D3DXMatrixTranspose(&amp;worldMatrix, &amp;worldMatrix);
	D3DXMatrixTranspose(&amp;viewMatrix, &amp;viewMatrix);
	D3DXMatrixTranspose(&amp;projectionMatrix, &amp;projectionMatrix);

	// Lock the constant buffer so it can be written to.
	result = deviceContext-&gt;Map(m_matrixBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource);
	if(FAILED(result))
	{
		return false;
	}

	// Get a pointer to the data in the constant buffer.
	dataPtr = (MatrixBufferType*)mappedResource.pData;

	// Copy the matrices into the constant buffer.
	dataPtr-&gt;world = worldMatrix;
	dataPtr-&gt;view = viewMatrix;
	dataPtr-&gt;projection = projectionMatrix;

	// Unlock the constant buffer.
	deviceContext-&gt;Unmap(m_matrixBuffer, 0);

	// Set the position of the constant buffer in the vertex shader.
	bufferNumber = 0;

	// Now set the constant buffer in the vertex shader with the updated values.
	deviceContext-&gt;VSSetConstantBuffers(bufferNumber, 1, &amp;m_matrixBuffer);</font><font face="arial" color="#aaaaff" size="2">

	// Set shader texture resource in the pixel shader.
	deviceContext-&gt;PSSetShaderResources(0, 1, &amp;texture);</font><font face="arial" color="#aaffaa" size="2">

	return true;
}


void TransparentDepthShaderClass::RenderShader(ID3D11DeviceContext* deviceContext, int indexCount)
{
	// Set the vertex input layout.
	deviceContext-&gt;IASetInputLayout(m_layout);

	// Set the vertex and pixel shaders that will be used to render this triangle.
	deviceContext-&gt;VSSetShader(m_vertexShader, NULL, 0);
	deviceContext-&gt;PSSetShader(m_pixelShader, NULL, 0);</font><font face="arial" color="#aaaaff" size="2">

	// Set the sampler state in the pixel shader.
	deviceContext-&gt;PSSetSamplers(0, 1, &amp;m_sampleState);</font><font face="arial" color="#aaffaa" size="2">

	// Render the triangle.
	deviceContext-&gt;DrawIndexed(indexCount, 0, 0);

	return;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Applicationclass.h</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We have added a TreeClass and the TransparentDepthShaderClass.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: applicationclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _APPLICATIONCLASS_H_
#define _APPLICATIONCLASS_H_


/////////////
// GLOBALS //
/////////////
const bool FULL_SCREEN = true;
const bool VSYNC_ENABLED = true;
const float SCREEN_DEPTH = 1000.0f;
const float SCREEN_NEAR = 0.1f;

const int SHADOWMAP_WIDTH = 1024;
const int SHADOWMAP_HEIGHT = 1024;
const float SHADOWMAP_DEPTH = 50.0f;
const float SHADOWMAP_NEAR = 1.0f;


///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "inputclass.h"
#include "d3dclass.h"
#include "timerclass.h"
#include "positionclass.h"
#include "cameraclass.h"
#include "lightclass.h"
#include "modelclass.h"</font><font face="arial" color="#aaaaff" size="2">
#include "treeclass.h"</font><font face="arial" color="#aaffaa" size="2">
#include "rendertextureclass.h"
#include "depthshaderclass.h"</font><font face="arial" color="#aaaaff" size="2">
#include "transparentdepthshaderclass.h"</font><font face="arial" color="#aaffaa" size="2">
#include "shadowshaderclass.h"


////////////////////////////////////////////////////////////////////////////////
// Class name: ApplicationClass
////////////////////////////////////////////////////////////////////////////////
class ApplicationClass
{
public:
	ApplicationClass();
	ApplicationClass(const ApplicationClass&amp;);
	~ApplicationClass();

	bool Initialize(HINSTANCE, HWND, int, int);
	void Shutdown();
	bool Frame();

private:
	bool HandleMovementInput(float);
	void UpdateLighting();
	bool Render();
	bool RenderSceneToTexture();

private:
	InputClass* m_Input;
	D3DClass* m_Direct3D;
	TimerClass* m_Timer;
	PositionClass* m_Position;
	CameraClass* m_Camera;
	LightClass* m_Light;</font><font face="arial" color="#aaaaff" size="2">
	ModelClass* m_GroundModel;
	TreeClass* m_Tree;</font><font face="arial" color="#aaffaa" size="2">
	RenderTextureClass* m_RenderTexture;
	DepthShaderClass* m_DepthShader;</font><font face="arial" color="#aaaaff" size="2">
	TransparentDepthShaderClass* m_TransparentDepthShader;</font><font face="arial" color="#aaffaa" size="2">
	ShadowShaderClass* m_ShadowShader;
};

#endif
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Applicationclass.cpp</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: applicationclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "applicationclass.h"


ApplicationClass::ApplicationClass()
{
	m_Input = 0;
	m_Direct3D = 0;
	m_Timer = 0;
	m_Position = 0;
	m_Camera = 0;
	m_Light = 0;</font><font face="arial" color="#aaaaff" size="2">
	m_GroundModel = 0;
	m_Tree = 0;</font><font face="arial" color="#aaffaa" size="2">
	m_RenderTexture = 0;
	m_DepthShader = 0;</font><font face="arial" color="#aaaaff" size="2">
	m_TransparentDepthShader = 0;</font><font face="arial" color="#aaffaa" size="2">
	m_ShadowShader = 0;
}


ApplicationClass::ApplicationClass(const ApplicationClass&amp; other)
{
}


ApplicationClass::~ApplicationClass()
{
}


bool ApplicationClass::Initialize(HINSTANCE hinstance, HWND hwnd, int screenWidth, int screenHeight)
{
	bool result;

	
	// Create the input object.  The input object will be used to handle reading the keyboard and mouse input from the user.
	m_Input = new InputClass;
	if(!m_Input)
	{
		return false;
	}

	// Initialize the input object.
	result = m_Input-&gt;Initialize(hinstance, hwnd, screenWidth, screenHeight);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the input object.", L"Error", MB_OK);
		return false;
	}

	// Create the Direct3D object.
	m_Direct3D = new D3DClass;
	if(!m_Direct3D)
	{
		return false;
	}

	// Initialize the Direct3D object.
	result = m_Direct3D-&gt;Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize DirectX 11.", L"Error", MB_OK);
		return false;
	}

	// Create the timer object.
	m_Timer = new TimerClass;
	if(!m_Timer)
	{
		return false;
	}

	// Initialize the timer object.
	result = m_Timer-&gt;Initialize();
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the timer object.", L"Error", MB_OK);
		return false;
	}

	// Create the position object.
	m_Position = new PositionClass;
	if(!m_Position)
	{
		return false;
	}

	// Set the initial position.
	m_Position-&gt;SetPosition(0.0f, 7.0f, -11.0f);
	m_Position-&gt;SetRotation(20.0f, 0.0f, 0.0f);
	
	// Create the camera object.
	m_Camera = new CameraClass;
	if(!m_Camera)
	{
		return false;
	}

	// Create the light object.
	m_Light = new LightClass;
	if(!m_Light)
	{
		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We try to generate a fairly tight shadow mapping area around the scene to increase the detail of the shadow map.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Initialize the light object.
	m_Light-&gt;GenerateOrthoMatrix(15.0f, 15.0f, SHADOWMAP_DEPTH, SHADOWMAP_NEAR);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Here is where we create the flat plane ground model for the scene.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Create the ground model object.
	m_GroundModel = new ModelClass;
	if(!m_GroundModel)
	{
		return false;
	}

	// Initialize the ground model object.
	result = m_GroundModel-&gt;Initialize(m_Direct3D-&gt;GetDevice(), "../Engine/data/plane01.txt", L"../Engine/data/dirt.dds", 2.0f);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the ground model object.", L"Error", MB_OK);
		return false;
	}

	// Set the position for the ground model.
	m_GroundModel-&gt;SetPosition(0.0f, 1.0f, 0.0f);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
And here is where we create the tree model.
It is the same as the model class except that non-transparent areas such as the trunk and branches are one buffer,
and transparent areas such as the leaves are a second separate buffer.
This enables us to render the different parts of the tree separately using different shaders for each.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Create the tree object.
	m_Tree = new TreeClass;
	if(!m_Tree)
	{
		return false;
	}

	// Initialize the shadow shader object.
	result = m_Tree-&gt;Initialize(m_Direct3D-&gt;GetDevice(), "../Engine/data/trees/trunk001.txt", L"../Engine/data/trees/trunk001.dds", 
				    "../Engine/data/trees/leaf001.txt", L"../Engine/data/trees/leaf001.dds", 0.1f);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the tree object.", L"Error", MB_OK);
		return false;
	}

	// Set the position for the tree model.
	m_Tree-&gt;SetPosition(0.0f, 1.0f, 0.0f);</font><font face="arial" color="#aaffaa" size="2">

	// Create the render to texture object.
	m_RenderTexture = new RenderTextureClass;
	if(!m_RenderTexture)
	{
		return false;
	}

	// Initialize the render to texture object.
	result = m_RenderTexture-&gt;Initialize(m_Direct3D-&gt;GetDevice(), SHADOWMAP_WIDTH, SHADOWMAP_HEIGHT, SHADOWMAP_DEPTH, SHADOWMAP_NEAR);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the render to texture object.", L"Error", MB_OK);
		return false;
	}

	// Create the depth shader object.
	m_DepthShader = new DepthShaderClass;
	if(!m_DepthShader)
	{
		return false;
	}

	// Initialize the depth shader object.
	result = m_DepthShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the depth shader object.", L"Error", MB_OK);
		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The new transparent depth shader is setup here.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Create the transparent depth shader object.
	m_TransparentDepthShader = new TransparentDepthShaderClass;
	if(!m_TransparentDepthShader)
	{
		return false;
	}

	// Initialize the transparent depth shader object.
	result = m_TransparentDepthShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the transparent depth shader object.", L"Error", MB_OK);
		return false;
	}</font><font face="arial" color="#aaffaa" size="2">

	// Create the shadow shader object.
	m_ShadowShader = new ShadowShaderClass;
	if(!m_ShadowShader)
	{
		return false;
	}

	// Initialize the shadow shader object.
	result = m_ShadowShader-&gt;Initialize(m_Direct3D-&gt;GetDevice(), hwnd);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the shadow shader object.", L"Error", MB_OK);
		return false;
	}

	return true;
}


void ApplicationClass::Shutdown()
{
	// Release the shadow shader object.
	if(m_ShadowShader)
	{
		m_ShadowShader-&gt;Shutdown();
		delete m_ShadowShader;
		m_ShadowShader = 0;
	}</font><font face="arial" color="#aaaaff" size="2">

	// Release the transparent depth shader object.
	if(m_TransparentDepthShader)
	{
		m_TransparentDepthShader-&gt;Shutdown();
		delete m_TransparentDepthShader;
		m_TransparentDepthShader = 0;
	}</font><font face="arial" color="#aaffaa" size="2">

	// Release the depth shader object.
	if(m_DepthShader)
	{
		m_DepthShader-&gt;Shutdown();
		delete m_DepthShader;
		m_DepthShader = 0;
	}

	// Release the render to texture object.
	if(m_RenderTexture)
	{
		m_RenderTexture-&gt;Shutdown();
		delete m_RenderTexture;
		m_RenderTexture = 0;
	}</font><font face="arial" color="#aaaaff" size="2">

	// Release the tree object.
	if(m_Tree)
	{
		m_Tree-&gt;Shutdown();
		delete m_Tree;
		m_Tree = 0;
	}

	// Release the ground model object.
	if(m_GroundModel)
	{
		m_GroundModel-&gt;Shutdown();
		delete m_GroundModel;
		m_GroundModel = 0;
	}</font><font face="arial" color="#aaffaa" size="2">

	// Release the light object.
	if(m_Light)
	{
		delete m_Light;
		m_Light = 0;
	}

	// Release the camera object.
	if(m_Camera)
	{
		delete m_Camera;
		m_Camera = 0;
	}
	
	// Release the position object.
	if(m_Position)
	{
		delete m_Position;
		m_Position = 0;
	}

	// Release the timer object.
	if(m_Timer)
	{
		delete m_Timer;
		m_Timer = 0;
	}

	// Release the Direct3D object.
	if(m_Direct3D)
	{
		m_Direct3D-&gt;Shutdown();
		delete m_Direct3D;
		m_Direct3D = 0;
	}

	// Release the input object.
	if(m_Input)
	{
		m_Input-&gt;Shutdown();
		delete m_Input;
		m_Input = 0;
	}

	return;
}


bool ApplicationClass::Frame()
{
	bool result;


	// Update the system stats.
	m_Timer-&gt;Frame();

	// Read the user input.
	result = m_Input-&gt;Frame();
	if(!result)
	{
		return false;
	}
	
	// Check if the user pressed escape and wants to exit the application.
	if(m_Input-&gt;IsEscapePressed() == true)
	{
		return false;
	}

	// Do the frame input processing.
	result = HandleMovementInput(m_Timer-&gt;GetTime());
	if(!result)
	{
		return false;
	}

	// Update the scene lighting.
	UpdateLighting();

	// Render the graphics.
	result = Render();
	if(!result)
	{
		return false;
	}

	return result;
}


bool ApplicationClass::HandleMovementInput(float frameTime)
{
	bool keyDown;
	float posX, posY, posZ, rotX, rotY, rotZ;


	// Set the frame time for calculating the updated position.
	m_Position-&gt;SetFrameTime(frameTime);

	// Handle the input.
	keyDown = m_Input-&gt;IsLeftPressed();
	m_Position-&gt;TurnLeft(keyDown);

	keyDown = m_Input-&gt;IsRightPressed();
	m_Position-&gt;TurnRight(keyDown);

	keyDown = m_Input-&gt;IsUpPressed();
	m_Position-&gt;MoveForward(keyDown);

	keyDown = m_Input-&gt;IsDownPressed();
	m_Position-&gt;MoveBackward(keyDown);

	keyDown = m_Input-&gt;IsAPressed();
	m_Position-&gt;MoveUpward(keyDown);

	keyDown = m_Input-&gt;IsZPressed();
	m_Position-&gt;MoveDownward(keyDown);

	keyDown = m_Input-&gt;IsPgUpPressed();
	m_Position-&gt;LookUpward(keyDown);

	keyDown = m_Input-&gt;IsPgDownPressed();
	m_Position-&gt;LookDownward(keyDown);
	
	// Get the view point position/rotation.
	m_Position-&gt;GetPosition(posX, posY, posZ);
	m_Position-&gt;GetRotation(rotX, rotY, rotZ);

	// Set the position of the camera.
	m_Camera-&gt;SetPosition(posX, posY, posZ);
	m_Camera-&gt;SetRotation(rotX, rotY, rotZ);

	return true;
}


void ApplicationClass::UpdateLighting()
{
	static float angle = 270.0f;
	float radians;
	static float offsetX = 9.0f;


	// Update direction of the light.
	angle -= 0.03f * m_Timer-&gt;GetTime();
	if(angle &lt; 90.0f)
	{
		angle = 270.0f;
		offsetX = 9.0f;
	}
	radians = angle * 0.0174532925f;
	m_Light-&gt;SetDirection(sinf(radians), cosf(radians), 0.0f);

	// Update the lookat and position.
	offsetX -= 0.003f * m_Timer-&gt;GetTime();
	m_Light-&gt;SetPosition(0.0f + offsetX, 10.0f, 1.0f);
	m_Light-&gt;SetLookAt(0.0f - offsetX, 0.0f, 2.0f);

	return;
}


bool ApplicationClass::Render()
{
	D3DXMATRIX worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, lightOrthoMatrix;
	D3DXVECTOR4 ambientColor, diffuseColor;
	float posX, posY, posZ;
	bool result;


	// Render the depth of the scene to a texture.
	result = RenderSceneToTexture();
	if(!result)
	{
		return false;
	}

	// Clear the scene.
	m_Direct3D-&gt;BeginScene(0.0f, 0.5f, 0.8f, 1.0f);

	// Generate the view matrix based on the camera's position.
	m_Camera-&gt;Render();

	// Generate the light view matrix based on the light's position.
	m_Light-&gt;GenerateViewMatrix();

	// Get the matrices from the camera and d3d objects.
	m_Direct3D-&gt;GetWorldMatrix(worldMatrix);
	m_Camera-&gt;GetViewMatrix(viewMatrix);
	m_Direct3D-&gt;GetProjectionMatrix(projectionMatrix);

	// Get the light's view and projection matrices from the light object.
	m_Light-&gt;GetViewMatrix(lightViewMatrix);
	m_Light-&gt;GetOrthoMatrix(lightOrthoMatrix);

	// Set the light color attributes.
	diffuseColor = D3DXVECTOR4(1.0f, 1.0f, 1.0f, 1.0f);
	ambientColor = D3DXVECTOR4(0.15f, 0.15f, 0.15f, 1.0f);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The ground model is rendered with the shadow shader as normal.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Translate to the position of the ground model.
	m_GroundModel-&gt;GetPosition(posX, posY, posZ);
	D3DXMatrixTranslation(&amp;worldMatrix, posX, posY, posZ);

	// Render the ground model using the shadow shader.
	m_GroundModel-&gt;Render(m_Direct3D-&gt;GetDeviceContext());
	m_ShadowShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, 
			       lightOrthoMatrix, m_GroundModel-&gt;GetTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(),
			       ambientColor, diffuseColor);
	m_Direct3D-&gt;GetWorldMatrix(worldMatrix);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The tree model is rendered in two parts.  First the opaque parts are drawn, and then the transparent parts are drawn after that.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Translate to the position of the tree model.
	m_Tree-&gt;GetPosition(posX, posY, posZ);
	D3DXMatrixTranslation(&amp;worldMatrix, posX, posY, posZ);

	// Render the tree trunk.
	m_Tree-&gt;RenderTrunk(m_Direct3D-&gt;GetDeviceContext());
	m_ShadowShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_Tree-&gt;GetTrunkIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, 
			       lightOrthoMatrix, m_Tree-&gt;GetTrunkTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), 
			       ambientColor, diffuseColor);

	// Enable blending and render the tree leaves.
	m_Direct3D-&gt;TurnOnAlphaBlending();
	m_Tree-&gt;RenderLeaves(m_Direct3D-&gt;GetDeviceContext());
	m_ShadowShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_Tree-&gt;GetLeafIndexCount(), worldMatrix, viewMatrix, projectionMatrix, lightViewMatrix, 
			       lightOrthoMatrix, m_Tree-&gt;GetLeafTexture(), m_RenderTexture-&gt;GetShaderResourceView(), m_Light-&gt;GetDirection(), 
			       ambientColor, diffuseColor);
	m_Direct3D-&gt;TurnOffAlphaBlending();
	m_Direct3D-&gt;GetWorldMatrix(worldMatrix);</font><font face="arial" color="#aaffaa" size="2">

	// Present the rendered scene to the screen.
	m_Direct3D-&gt;EndScene();

	return true;
}


bool ApplicationClass::RenderSceneToTexture()
{
	D3DXMATRIX worldMatrix, lightViewMatrix, lightOrthoMatrix;
	float posX, posY, posZ;
	bool result;


	// Set the render target to be the render to texture.
	m_RenderTexture-&gt;SetRenderTarget(m_Direct3D-&gt;GetDeviceContext());

	// Clear the render to texture.
	m_RenderTexture-&gt;ClearRenderTarget(m_Direct3D-&gt;GetDeviceContext(), 0.0f, 0.0f, 0.0f, 1.0f);

	// Get the world matrix from the d3d object.
	m_Direct3D-&gt;GetWorldMatrix(worldMatrix);

	// Generate the light view matrix based on the light's position.
	m_Light-&gt;GenerateViewMatrix();

	// Get the view and orthographic matrices from the light object.
	m_Light-&gt;GetViewMatrix(lightViewMatrix);
	m_Light-&gt;GetOrthoMatrix(lightOrthoMatrix);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
First render the opaque parts of the trunk (trunk and branches) using the regular depth shader.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Translate to the position of the tree.
	m_Tree-&gt;GetPosition(posX, posY, posZ);
	D3DXMatrixTranslation(&amp;worldMatrix, posX, posY, posZ);

	// Render the tree trunk with the depth shader.
	m_Tree-&gt;RenderTrunk(m_Direct3D-&gt;GetDeviceContext());
	m_DepthShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_Tree-&gt;GetTrunkIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Here is the key part.  We render the transparent parts of the tree using the transparent depth shader and the transparency texture onto the same render to texture object.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Render the tree leaves using the depth transparency shader.
	m_Tree-&gt;RenderLeaves(m_Direct3D-&gt;GetDeviceContext());
	result = m_TransparentDepthShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_Tree-&gt;GetLeafIndexCount(), worldMatrix, lightViewMatrix, 
						  lightOrthoMatrix, m_Tree-&gt;GetLeafTexture());
	if(!result)
	{
		return false;
	}

	// Reset the world matrix.
	m_Direct3D-&gt;GetWorldMatrix(worldMatrix);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
And finally render the ground model as normal using the regular depth shader.
</font></p>

<pre><font face="arial" color="#aaaaff" size="2">	// Translate to the position of the ground model.
	m_GroundModel-&gt;GetPosition(posX, posY, posZ);
	D3DXMatrixTranslation(&amp;worldMatrix, posX, posY, posZ);

	// Render the ground model with the depth shader.
	m_GroundModel-&gt;Render(m_Direct3D-&gt;GetDeviceContext());
	m_DepthShader-&gt;Render(m_Direct3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, lightViewMatrix, lightOrthoMatrix);</font><font face="arial" color="#aaffaa" size="2">

	// Reset the render target back to the original back buffer and not the render to texture anymore.
	m_Direct3D-&gt;SetBackBufferRenderTarget();

	// Reset the viewport back to the original.
	m_Direct3D-&gt;ResetViewport();

	return true;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Summary</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
With a transparent depth shader we can now use transparency textures with our shadow maps.
</font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic0294.gif" width="400" height="360"></p>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>To Do Exercises</u></font></p>
 
<p align="left"><font face="Arial" size="2" color="#FFFFFF">
1. Compile and run the program.  Use the arrow keys, A, Z, PgUp, and PgDn to view the scene.
</font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
2. Create your own model with transparency textures and render it using this method.
</font></p>

<br>
<p align="center"><font face="Arial" size="3" color="#FFFFFF"><u>Source Code</u></font></p>
<p align="center"><font face="Arial" size="2" color="#FFFFFF">Source Code and Data Files: <a href="http://www.rastertek.com/dx11src49.zip">dx11src49.zip</a></font></p>
<p align="center"><font face="Arial" size="2" color="#FFFFFF">Executable: <a href="http://www.rastertek.com/dx11exe49.zip">dx11exe49.zip</a></font></p>

<p align="center"><img border="0" src="./Tutorial 49_ Shadow Mapping and Transparency_files/pic1002.gif" width="800" height="1"></p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="2" color="#CCCCCC"><a href="http://www.rastertek.com/tutdx11.html">Back to Tutorial Index</a></font></p>
</body><div id="cVim-status-bar" style="top: 0px;"></div><iframe src="./Tutorial 49_ Shadow Mapping and Transparency_files/cmdline_frame.html" id="cVim-command-frame"></iframe></html>