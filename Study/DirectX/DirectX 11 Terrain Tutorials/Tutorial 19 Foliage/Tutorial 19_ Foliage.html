
<!-- saved from url=(0038)http://www.rastertek.com/tertut19.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Tutorial 19: Foliage</title><style>#cVim-command-bar, #cVim-command-bar-mode, #cVim-command-bar-input, #cVim-command-bar-search-results,
.cVim-completion-item, .cVim-completion-item .cVim-full, .cVim-completion-item .cVim-left,
.cVim-completion-item .cVim-right {
  font-family: Helvetica, Helvetica Neue, Neue, sans-serif, monospace, Arial;
  font-size: 10pt !important;
  -webkit-font-smoothing: antialiased !important;
}

#cVim-command-bar {
  position: fixed;
  z-index: 2147483646;
  background-color: #1b1d1e;
  color: #bbb;
  display: none;
  box-sizing: content-box;
  box-shadow: 0 3px 3px rgba(0,0,0,0.4);
  left: 0;
  width: 100%;
  height: 20px;
}

#cVim-command-bar-mode {
  display: inline-block;
  vertical-align: middle;
  box-sizing: border-box;
  padding-left: 2px;
  height: 100%;
  width: 10px;
  padding-top: 2px;
  color: #888;
}

#cVim-command-bar-input {
  background-color: #1b1d1e;
  color: #bbb;
  height: 100%;
  right: 0;
  top: 0;
  width: calc(100% - 10px);
  position: absolute;
}

#cVim-command-bar-search-results {
  position: fixed;
  width: 100%;
  overflow: hidden;
  z-index: 2147483647;
  left: 0;
  box-shadow: 0 3px 3px rgba(0,0,0,0.4);
  background-color: #1c1c1c;
}

.cVim-completion-item, .cVim-completion-item .cVim-full, .cVim-completion-item .cVim-left, .cVim-completion-item .cVim-right {
  text-overflow: ellipsis;
  padding: 1px;
  display: inline-block;
  box-sizing: border-box;
  vertical-align: middle;
  overflow: hidden;
  white-space: nowrap;
}

.cVim-completion-item:nth-child(even) {
  background-color: #1f1f1f;
}

.cVim-completion-item {
  width: 100%; left: 0;
  color: #bcbcbc;
}

.cVim-completion-item[active] {
  width: 100%; left: 0;
  color: #1b1d1e;
  background-color: #f1f1f1;
}

.cVim-completion-item[active] span {
  color: #1b1d1e;
}

.cVim-completion-item .cVim-left {
  color: #fff;
  width: 37%;
}

.cVim-completion-item .cVim-right {
  font-style: italic;
  color: #888;
  width: 57%;
}


#cVim-link-container, .cVim-link-hint,
#cVim-hud, #cVim-status-bar {
  font-family: Helvetica, Helvetica Neue, Neue, sans-serif, monospace, Arial;
  font-size: 10pt !important;
  -webkit-font-smoothing: antialiased !important;
}

#cVim-link-container {
  position: absolute;
  pointer-events: none;
  width: 100%; left: 0;
  height: 100%; top: 0;
  z-index: 2147483647;
}

.cVim-link-hint {
  position: absolute;
  color: #302505 !important;
  background-color: #ffd76e !important;
  border-radius: 2px !important;
  padding: 2px !important;
  font-size: 8pt !important;
  font-weight: 500 !important;
  text-transform: uppercase !important;
  border: 1px solid #ad810c;
  display: inline-block !important;
  vertical-align: middle !important;
  text-align: center !important;
  box-shadow: 2px 2px 1px rgba(0,0,0,0.25) !important;
}

.cVim-link-hint_match {
  color: #777;
  text-transform: uppercase !important;
}


#cVim-hud {
  background-color: rgba(28,28,28,0.9);
  position: fixed !important;
  transition: right 0.2s ease-out;
  z-index: 24724289;
}

#cVim-hud span {
  padding: 2px;
  padding-left: 4px;
  padding-right: 4px;
  color: #8f8f8f;
  font-size: 10pt;
}

#cVim-frames-outline {
  position: fixed;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  right: 0;
  z-index: 9999999999;
  box-sizing: border-box;
  border: 3px solid yellow;
}
</style><link type="text/css" rel="stylesheet" href="chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/content.css"></head>
<body text="#FFFFFF" bgcolor="#000000" style="width:1000px">

<p align="center"><font face="Arial" size="4" color="#FFFFFF"><b>
Tutorial 19: Foliage
</b></font></p>

<p align="center"><img border="0" src="./Tutorial 19_ Foliage_files/pic3001.gif" width="1024" height="1"></p>

<p align="center"><img border="0" src="./Tutorial 19_ Foliage_files/pic0299.gif" width="802" height="452"></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
In this terrain tutorial we will cover one of the methods for implementing foliage in DirectX 11 using HLSL and C++.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
There are many different methods for rendering foliage on terrain.
The first method is to just render a number of complete plant models.
A second method that is commonly used is to use two or three quads intersecting each other with a plant texture to create the illusion of a complete plant model.
The third method used is just a single quad with a plant texture placed hundreds of times on the ground and rotated towards the viewer.
And finally a fourth method uses a combination of all three methods paired with some LOD settings based on the viewer's position.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The first method obviously looks the best but seriously limits how much foliage can be used.
The second method is a good solution because it gives the illusion of a full model with a very small polygon count.
The third method has an even lower polygon count and allows for a large amount of foliage to be placed.
And finally combining the three methods can give the best possible results.
For this tutorial we will implement the third method.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
When rendering foliage you generally do not need to render it at great distances, in fact most engines won't render foliage past 50 meters or so.
It is good to set a distance value that you can manipulate to see what works best for your own engine.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
Also most engines animate foliage by default since it is trivial to do so.
Some simply rotate it back and forth, and others use more advanced systems such as perlin noise textures 
to simulate different velocities of coherent speeds to create wind blowing through fields of grass.
It is really up to you how far you want to take the animation of your foliage.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
As most systems use a plant texture with an alpha channel it becomes necessary to use a good blending method.
You can sort by depth and render in reverse order but it is a lot easier and artifact-free to just use the DirectX alpha-to-coverage blending method.
We will be using the alpha-to-coverage blending mode for this tutorial.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
Finally we will be using instancing to give each grass quad its own unique properties.
In this tutorial we will give each grass quad a unique location, rotation, and color.
And because we use instancing we only put a single grass quad on the pipeline and the rest is just instance data.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We will start the tutorial by looking at the new FoliageClass.
</font></p><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Foliageclass.h</u></font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The FoliageClass encapsulates everything to do with the foliage including the model, texture, instancing data, and animation.
This class contains just the basics to keep the tutorial simple.
</font></p><pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: foliageclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _FOLIAGECLASS_H_
#define _FOLIAGECLASS_H_


//////////////
// INCLUDES //
//////////////
#include &lt;d3d11.h&gt;
#include &lt;d3dx10math.h&gt;
#include &lt;time.h&gt;


///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "textureclass.h"


////////////////////////////////////////////////////////////////////////////////
// Class name: FoliageClass
////////////////////////////////////////////////////////////////////////////////
class FoliageClass
{
private:
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The VertexType will contain just the position and texture coordinates.
All other information about the foliage will be located in the instance buffer.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	struct VertexType
	{
		D3DXVECTOR3 position;
		D3DXVECTOR2 texture;
	};
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
This structure will be used to define the attributes of our foliage that will be stored in an array.
In this tutorial it will have an X and Z position, as well as a color.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	struct FoliageType
	{
		float x, z;
		float r, g, b;
	};
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The foliage will be instanced for position, rotation (rotated to the viewer, and rotated according to the wind), and the color of each grass quad.
The position and two rotations are stored in the single matrix.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	struct InstanceType
	{
		D3DXMATRIX matrix;
		D3DXVECTOR3 color;
	};

public:
	FoliageClass();
	FoliageClass(const FoliageClass&amp;);
	~FoliageClass();

	bool Initialize(ID3D11Device*, WCHAR*, int);
	void Shutdown();
	void Render(ID3D11DeviceContext*);
	bool Frame(D3DXVECTOR3, ID3D11DeviceContext*);

	int GetVertexCount();
	int GetInstanceCount();

	ID3D11ShaderResourceView* GetTexture();

private:
	bool InitializeBuffers(ID3D11Device*);
	void ShutdownBuffers();
	void RenderBuffers(ID3D11DeviceContext*);

	bool LoadTexture(ID3D11Device*, WCHAR*);
	void ReleaseTexture();

	bool GeneratePositions();

private:
	int m_foliageCount;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We will store the position and color of each piece of foliage in the m_foliageArray.
We will use the data here to build the instance array.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	FoliageType* m_foliageArray;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We will store all the matrices and colors for each piece of foliage in the m_foliageArray.
Each frame we will update it and then copy it into the instance buffer for rendering.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	InstanceType* m_Instances;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We use a vertex and instance buffer to render the foliage.
We don't require an index buffer when we are using instance buffers.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	ID3D11Buffer *m_vertexBuffer, *m_instanceBuffer;
	int m_vertexCount, m_instanceCount;
	TextureClass* m_Texture;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We have a couple variables for storing the wind direction and rotation.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	float m_windRotation;
	int m_windDirection;
};

#endif
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Foliageclass.cpp</u></font></p><pre><font face="arial" color="#aaffaa" size="2">///////////////////////////////////////////////////////////////////////////////
// Filename: foliageclass.cpp
///////////////////////////////////////////////////////////////////////////////
#include "foliageclass.h"


FoliageClass::FoliageClass()
{
	m_foliageArray = 0;
	m_Instances = 0;

	m_vertexBuffer = 0;
	m_instanceBuffer = 0;
	m_Texture = 0;
}


FoliageClass::FoliageClass(const FoliageClass&amp; other)
{
}


FoliageClass::~FoliageClass()
{
}


bool FoliageClass::Initialize(ID3D11Device* device, WCHAR* textureFilename, int fCount)
{
	bool result;


	// Set the foliage count.
	m_foliageCount = fCount;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
At the beginning of the Initialize function we call GeneratePositions to load the m_foliageArray with random foliage positions.
It will also generate the unique colors for each piece of foliage and store it all in the array.
This has to be called first since the InitializeBuffers function that follows will use this array to create the instance buffer for rendering the foliage.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Generate the positions of the foliage.
	result = GeneratePositions();
	if(!result)
	{
		return false;
	}

	// Initialize the vertex and instance buffer that hold the geometry for the foliage model.
	result = InitializeBuffers(device);
	if(!result)
	{
		return false;
	}

	// Load the texture for this model.
	result = LoadTexture(device, textureFilename);
	if(!result)
	{
		return false;
	}

	// Set the initial wind rotation and direction.
	m_windRotation = 0.0f;
	m_windDirection = 1;

	return true;
}


void FoliageClass::Shutdown()
{
	// Release the model texture.
	ReleaseTexture();

	// Release the vertex and instance buffers.
	ShutdownBuffers();

	// Release the foliage array.
	if(m_foliageArray)
	{
		delete [] m_foliageArray;
		m_foliageArray = 0;
	}

	return;
}


void FoliageClass::Render(ID3D11DeviceContext* deviceContext)
{
	// Put the vertex and instance buffers on the graphics pipeline to prepare them for drawing.
	RenderBuffers(deviceContext);

	return;
}
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The Frame function is called every frame and updates the direction of the wind and the rotation of the foliage with respect to the wind rotation.
The camera position is also taken into account and a final matrix composed of the position, X rotation, and Z rotation of each piece of foliage is created and stored in the m_Instances array.
Once all of the foliage rotations are calculated and stored we then copy the m_Instances array into the instance buffer which is used for rendering this frame.
</font></p><pre><font face="arial" color="#aaffaa" size="2">bool FoliageClass::Frame(D3DXVECTOR3 cameraPosition, ID3D11DeviceContext* deviceContext)
{
	D3DXMATRIX rotateMatrix, translationMatrix, rotateMatrix2, finalMatrix;
	D3DXVECTOR3 modelPosition;
	int i;
	double angle;
	float rotation, windRotation;
	HRESULT result;
	D3D11_MAPPED_SUBRESOURCE mappedResource;
	InstanceType* instancesPtr;


	// Update the wind rotation.
	if(m_windDirection == 1)
	{
		m_windRotation += 0.1f;
		if(m_windRotation &gt; 10.0f)
		{
			m_windDirection = 2;
		}
	}
	else
	{
		m_windRotation -= 0.1f;
		if(m_windRotation &lt; -10.0f)
		{
			m_windDirection = 1;
		}
	}

	// Load the instance buffer with the updated locations.
	for(i=0; i&lt;m_foliageCount; i++)
	{
		// Get the position of this piece of foliage.
		modelPosition.x = m_foliageArray[i].x;
		modelPosition.y = -0.1f;
		modelPosition.z = m_foliageArray[i].z;

		// Calculate the rotation that needs to be applied to the billboard model to face the current camera position using the arc tangent function.
		angle = atan2(modelPosition.x - cameraPosition.x, modelPosition.z - cameraPosition.z) * (180.0 / D3DX_PI);

		// Convert rotation into radians.
		rotation = (float)angle * 0.0174532925f;

		// Setup the X rotation of the billboard.
		D3DXMatrixRotationY(&amp;rotateMatrix, rotation);

		// Get the wind rotation for the foliage.
		windRotation = m_windRotation * 0.0174532925f;

		// Setup the wind rotation.
		D3DXMatrixRotationX(&amp;rotateMatrix2, windRotation);

		// Setup the translation matrix.
		D3DXMatrixTranslation(&amp;translationMatrix, modelPosition.x, modelPosition.y, modelPosition.z); 

		// Create the final matrix and store it in the instances array.
		D3DXMatrixMultiply(&amp;finalMatrix, &amp;rotateMatrix, &amp;rotateMatrix2); 
		D3DXMatrixMultiply(&amp;m_Instances[i].matrix, &amp;finalMatrix, &amp;translationMatrix);
	}

	// Lock the instance buffer so it can be written to.
	result = deviceContext-&gt;Map(m_instanceBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource);
	if(FAILED(result))
	{
		return false;
	}

	// Get a pointer to the data in the instance buffer.
	instancesPtr = (InstanceType*)mappedResource.pData;

	// Copy the instances array into the instance buffer.
	memcpy(instancesPtr, (void*)m_Instances, (sizeof(InstanceType) * m_foliageCount));

	// Unlock the instance buffer.
	deviceContext-&gt;Unmap(m_instanceBuffer, 0);

	return true;
}


int FoliageClass::GetVertexCount()
{
	return m_vertexCount;
}


int FoliageClass::GetInstanceCount()
{
	return m_instanceCount;
}


ID3D11ShaderResourceView* FoliageClass::GetTexture()
{
	return m_Texture-&gt;GetTexture();
}


bool FoliageClass::InitializeBuffers(ID3D11Device* device)
{
	VertexType* vertices;
	D3D11_BUFFER_DESC vertexBufferDesc, instanceBufferDesc;
	D3D11_SUBRESOURCE_DATA vertexData, instanceData;
	HRESULT result;
	int i;
	D3DXMATRIX matrix;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We create a single quad for the foliage.  It requires just position and texture coordinates.
Since we are using instancing we will just re-render this same quad for each piece of foliage that we have.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Set the number of vertices in the vertex array.
	m_vertexCount = 6;

	// Create the vertex array.
	vertices = new VertexType[m_vertexCount];
	if(!vertices)
	{
		return false;
	}

	// Load the vertex array with data.
	vertices[0].position = D3DXVECTOR3(0.0f, 0.0f, 0.0f);  // Bottom left.
	vertices[0].texture = D3DXVECTOR2(0.0f, 1.0f);

	vertices[1].position = D3DXVECTOR3(0.0f, 1.0f, 0.0f);  // Top left.
	vertices[1].texture = D3DXVECTOR2(0.0f, 0.0f);

	vertices[2].position = D3DXVECTOR3(1.0f, 0.0f, 0.0f);  // Bottom right.
	vertices[2].texture = D3DXVECTOR2(1.0f, 1.0f);

	vertices[3].position = D3DXVECTOR3(1.0f, 0.0f, 0.0f);  // Bottom right.
	vertices[3].texture = D3DXVECTOR2(1.0f, 1.0f);

	vertices[4].position = D3DXVECTOR3(0.0f, 1.0f, 0.0f);  // Top left.
	vertices[4].texture = D3DXVECTOR2(0.0f, 0.0f);

	vertices[5].position = D3DXVECTOR3(1.0f, 1.0f, 0.0f);  // Top right.
	vertices[5].texture = D3DXVECTOR2(1.0f, 0.0f);

	// Set up the description of the vertex buffer.
	vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	vertexBufferDesc.ByteWidth = sizeof(VertexType) * m_vertexCount;
	vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	vertexBufferDesc.CPUAccessFlags = 0;
	vertexBufferDesc.MiscFlags = 0;
	vertexBufferDesc.StructureByteStride = 0;

	// Give the subresource structure a pointer to the vertex data.
	vertexData.pSysMem = vertices;
	vertexData.SysMemPitch = 0;
	vertexData.SysMemSlicePitch = 0;

	// Now finally create the vertex buffer.
	result = device-&gt;CreateBuffer(&amp;vertexBufferDesc, &amp;vertexData, &amp;m_vertexBuffer);
	if(FAILED(result))
	{
		return false;
	}

	// Release the array now that the vertex buffer has been created and loaded.
	delete [] vertices;
	vertices = 0;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
Here we setup the instance buffer.
We are instancing the position and rotation, as well as the color.
The position and rotation are stored in a single matrix.
This matrix is updated each frame according to the camera position and the wind rotation.
At first we just use an identity matrix since we won't be rendering the very first instance buffer until it is updated during the Frame function.
We do however copy the color information into the instance array as the color is going to stay the same.
The instance array is used to create the initial instance buffer.
Note that we set the usage of the instance buffer to dynamic since we will be updating the instance buffer from the instance array every single frame.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Set the number of instances in the array.
	m_instanceCount = m_foliageCount;

	// Create the instance array.
	m_Instances = new InstanceType[m_instanceCount];
	if(!m_Instances)
	{
		return false;
	}

	// Setup an initial matrix.
	D3DXMatrixIdentity(&amp;matrix);

	// Load the instance array with data.
	for(i=0; i&lt;m_instanceCount; i++)
	{
		m_Instances[i].matrix = matrix;
		m_Instances[i].color = D3DXVECTOR3(m_foliageArray[i].r, m_foliageArray[i].g, m_foliageArray[i].b);
	}

	// Set up the description of the instance buffer.
	instanceBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	instanceBufferDesc.ByteWidth = sizeof(InstanceType) * m_instanceCount;
	instanceBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	instanceBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	instanceBufferDesc.MiscFlags = 0;
	instanceBufferDesc.StructureByteStride = 0;

	// Give the subresource structure a pointer to the instance data.
	instanceData.pSysMem = m_Instances;
	instanceData.SysMemPitch = 0;
	instanceData.SysMemSlicePitch = 0;

	// Create the instance buffer.
	result = device-&gt;CreateBuffer(&amp;instanceBufferDesc, &amp;instanceData, &amp;m_instanceBuffer);
	if(FAILED(result))
	{
		return false;
	}

	return true;
}


void FoliageClass::ShutdownBuffers()
{
	// Release the instance buffer.
	if(m_instanceBuffer)
	{
		m_instanceBuffer-&gt;Release();
		m_instanceBuffer = 0;
	}

	// Release the vertex buffer.
	if(m_vertexBuffer)
	{
		m_vertexBuffer-&gt;Release();
		m_vertexBuffer = 0;
	}

	// Release the instance array.
	if(m_Instances)
	{
		delete [] m_Instances;
		m_Instances = 0;
	}

	return;
}


void FoliageClass::RenderBuffers(ID3D11DeviceContext* deviceContext)
{
	unsigned int strides[2];
	unsigned int offsets[2];
	ID3D11Buffer* bufferPointers[2];


	// Set the buffer strides.
	strides[0] = sizeof(VertexType); 
	strides[1] = sizeof(InstanceType); 

	// Set the buffer offsets.
	offsets[0] = 0;
	offsets[1] = 0;

	// Set the array of pointers to the vertex and instance buffers.
	bufferPointers[0] = m_vertexBuffer;	
	bufferPointers[1] = m_instanceBuffer;

	// Set the vertex and instance buffers to active in the input assembler so it can be rendered.
	deviceContext-&gt;IASetVertexBuffers(0, 2, bufferPointers, strides, offsets);

	// Set the type of primitive that should be rendered from this vertex buffer, in this case triangles.
	deviceContext-&gt;IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	return;
}


bool FoliageClass::LoadTexture(ID3D11Device* device, WCHAR* filename)
{
	bool result;


	// Create the texture object.
	m_Texture = new TextureClass;
	if(!m_Texture)
	{
		return false;
	}

	// Initialize the texture object.
	result = m_Texture-&gt;Initialize(device, filename);
	if(!result)
	{
		return false;
	}

	return true;
}


void FoliageClass::ReleaseTexture()
{
	// Release the texture object.
	if(m_Texture)
	{
		m_Texture-&gt;Shutdown();
		delete m_Texture;
		m_Texture = 0;
	}

	return;
}
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The GeneratePositions function randomly assigns positions to each piece of foliage on the stone plane.
It also generates a random color for each piece of foliage.
This data is used to instance each piece of foliage for rendering.
</font></p><pre><font face="arial" color="#aaffaa" size="2">bool FoliageClass::GeneratePositions()
{
	int i;
	float red, green;


	// Create an array to store all the foliage information.
	m_foliageArray = new FoliageType[m_foliageCount];
	if(!m_foliageArray)
	{
		return false;
	}

	// Seed the random generator.
	srand((int)time(NULL));

	// Set random positions and random colors for each piece of foliage.
	for(i=0; i&lt;m_foliageCount; i++)
	{
		m_foliageArray[i].x = ((float)rand() / (float)(RAND_MAX)) * 9.0f - 4.5f;
		m_foliageArray[i].z = ((float)rand() / (float)(RAND_MAX)) * 9.0f - 4.5f;

		red = ((float)rand() / (float)(RAND_MAX)) * 1.0f;
		green = ((float)rand() / (float)(RAND_MAX)) * 1.0f;

		m_foliageArray[i].r = red + 1.0f;
		m_foliageArray[i].g = green + 0.5f;
		m_foliageArray[i].b = 0.0f;
	}

	return true;
}
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Foliage.vs</u></font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The foliage HLSL shader uses instancing to render many unique pieces of foliage from a single two triangle model.
</font></p><pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: foliage.vs
////////////////////////////////////////////////////////////////////////////////
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
In the MatrixBuffer you will notice there is no world matrix.
The reason for that is that it needs to be instanced and read in from the instance buffer to give each piece of foliage its own unique position and rotation.
</font></p><pre><font face="arial" color="#aaffaa" size="2">/////////////
// GLOBALS //
/////////////
cbuffer MatrixBuffer
{
    matrix viewMatrix;
    matrix projectionMatrix;
};


//////////////
// TYPEDEFS //
//////////////
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The VertexInputType contains the position and texture coordinates as usual.
What is new is the instanced data for the world matrix and the instanced data for the foliage color.
Notice we need to specify row major ordering for the instanced world matrix.
</font></p><pre><font face="arial" color="#aaffaa" size="2">struct VertexInputType
{
    float4 position : POSITION;
    float2 tex : TEXCOORD0;
    row_major matrix instanceWorld : WORLD;
    float3 instanceColor : TEXCOORD1;
};

struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 foliageColor : TEXCOORD1;
};


////////////////////////////////////////////////////////////////////////////////
// Vertex Shader
////////////////////////////////////////////////////////////////////////////////
PixelInputType FoliageVertexShader(VertexInputType input)
{
    PixelInputType output;
    

    // Change the position vector to be 4 units for proper matrix calculations.
    input.position.w = 1.0f;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The position is first multiplied by our new instanced world matrix.
Each piece of foliage has a unique world matrix composed of their position and rotation.
</font></p><pre><font face="arial" color="#aaffaa" size="2">    // Calculate the position of the vertex against the world, view, and projection matrices.
    output.position = mul(input.position, input.instanceWorld);
    output.position = mul(output.position, viewMatrix);
    output.position = mul(output.position, projectionMatrix);
    
    // Store the texture coordinates for the pixel shader.
    output.tex = input.tex;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We send the instanced foliage color into the pixel shader.
</font></p><pre><font face="arial" color="#aaffaa" size="2">    // Send the instanced foliage color into the pixel shader.
    output.foliageColor = input.instanceColor;

    return output;
}
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Foliage.ps</u></font></p><pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: foliage.ps
////////////////////////////////////////////////////////////////////////////////


/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
SamplerState SampleType;


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
    float3 foliageColor : TEXCOORD1;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 FoliagePixelShader(PixelInputType input) : SV_TARGET
{
    float4 textureColor;
    float4 color;


    // Sample the pixel color from the texture using the sampler at this texture coordinate location.
    textureColor = shaderTexture.Sample(SampleType, input.tex);

    // Combine the texture and the foliage color.
    color = textureColor * float4(input.foliageColor, 1.0f);

    // Saturate the final color result.
    color = saturate(color);

    return color;
}
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Foliageshaderclass.h</u></font></p><pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: foliageshaderclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _FOLIAGESHADERCLASS_H_
#define _FOLIAGESHADERCLASS_H_


//////////////
// INCLUDES //
//////////////
#include &lt;d3d11.h&gt;
#include &lt;d3dx10math.h&gt;
#include &lt;d3dx11async.h&gt;
#include &lt;fstream&gt;
using namespace std;


////////////////////////////////////////////////////////////////////////////////
// Class name: FoliageShaderClass
////////////////////////////////////////////////////////////////////////////////
class FoliageShaderClass
{
private:
	struct MatrixBufferType
	{
		D3DXMATRIX view;
		D3DXMATRIX projection;
	};

public:
	FoliageShaderClass();
	FoliageShaderClass(const FoliageShaderClass&amp;);
	~FoliageShaderClass();

	bool Initialize(ID3D11Device*, HWND);
	void Shutdown();
	bool Render(ID3D11DeviceContext*, int, int, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*);

private:
	bool InitializeShader(ID3D11Device*, HWND, WCHAR*, WCHAR*);
	void ShutdownShader();
	void OutputShaderErrorMessage(ID3D10Blob*, HWND, WCHAR*);

	bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*);
	void RenderShader(ID3D11DeviceContext*, int, int);

private:
	ID3D11VertexShader* m_vertexShader;
	ID3D11PixelShader* m_pixelShader;
	ID3D11InputLayout* m_layout;
	ID3D11Buffer* m_matrixBuffer;
	ID3D11SamplerState* m_sampleState;
};

#endif
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Foliageshaderclass.cpp</u></font></p><pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: foliageshaderclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "foliageshaderclass.h"


FoliageShaderClass::FoliageShaderClass()
{
	m_vertexShader = 0;
	m_pixelShader = 0;
	m_layout = 0;
	m_matrixBuffer = 0;
	m_sampleState = 0;
}


FoliageShaderClass::FoliageShaderClass(const FoliageShaderClass&amp; other)
{
}


FoliageShaderClass::~FoliageShaderClass()
{
}


bool FoliageShaderClass::Initialize(ID3D11Device* device, HWND hwnd)
{
	bool result;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We load in the foliage HLSL files here.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Initialize the vertex and pixel shaders.
	result = InitializeShader(device, hwnd, L"../Engine/foliage.vs", L"../Engine/foliage.ps");
	if(!result)
	{
		return false;
	}

	return true;
}


void FoliageShaderClass::Shutdown()
{
	// Shutdown the vertex and pixel shaders as well as the related objects.
	ShutdownShader();

	return;
}
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
The Render function requires the vertex and instance count instead of the index count.  This is because we are rendering using instance buffers and not index buffers.
</font></p><pre><font face="arial" color="#aaffaa" size="2">bool FoliageShaderClass::Render(ID3D11DeviceContext* deviceContext, int vertexCount, int instanceCount, D3DXMATRIX viewMatrix, 
				D3DXMATRIX projectionMatrix, ID3D11ShaderResourceView* texture)
{
	bool result;


	// Set the shader parameters that it will use for rendering.
	result = SetShaderParameters(deviceContext, viewMatrix, projectionMatrix, texture);
	if(!result)
	{
		return false;
	}

	// Now render the prepared buffers with the shader.
	RenderShader(deviceContext, vertexCount, instanceCount);

	return true;
}


bool FoliageShaderClass::InitializeShader(ID3D11Device* device, HWND hwnd, WCHAR* vsFilename, WCHAR* psFilename)
{
	HRESULT result;
	ID3D10Blob* errorMessage;
	ID3D10Blob* vertexShaderBuffer;
	ID3D10Blob* pixelShaderBuffer;
	D3D11_INPUT_ELEMENT_DESC polygonLayout[7];
	unsigned int numElements;
	D3D11_BUFFER_DESC matrixBufferDesc;
	D3D11_SAMPLER_DESC samplerDesc;


	// Initialize the pointers this function will use to null.
	errorMessage = 0;
	vertexShaderBuffer = 0;
	pixelShaderBuffer = 0;

	// Compile the vertex shader code.
	result = D3DX11CompileFromFile(vsFilename, NULL, NULL, "FoliageVertexShader", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL, 
				       &amp;vertexShaderBuffer, &amp;errorMessage, NULL);
	if(FAILED(result))
	{
		// If the shader failed to compile it should have written something to the error message.
		if(errorMessage)
		{
			OutputShaderErrorMessage(errorMessage, hwnd, vsFilename);
		}
		// If there was nothing in the error message then it simply could not find the shader file itself.
		else
		{
			MessageBox(hwnd, vsFilename, L"Missing Shader File", MB_OK);
		}

		return false;
	}

	// Compile the pixel shader code.
	result = D3DX11CompileFromFile(psFilename, NULL, NULL, "FoliagePixelShader", "ps_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 0, NULL, 
				       &amp;pixelShaderBuffer, &amp;errorMessage, NULL);
	if(FAILED(result))
	{
		// If the shader failed to compile it should have written something to the error message.
		if(errorMessage)
		{
			OutputShaderErrorMessage(errorMessage, hwnd, psFilename);
		}
		// If there was  nothing in the error message then it simply could not find the file itself.
		else
		{
			MessageBox(hwnd, psFilename, L"Missing Shader File", MB_OK);
		}

		return false;
	}

	// Create the vertex shader from the buffer.
	result = device-&gt;CreateVertexShader(vertexShaderBuffer-&gt;GetBufferPointer(), vertexShaderBuffer-&gt;GetBufferSize(), NULL, &amp;m_vertexShader);
	if(FAILED(result))
	{
		return false;
	}

	// Create the pixel shader from the buffer.
	result = device-&gt;CreatePixelShader(pixelShaderBuffer-&gt;GetBufferPointer(), pixelShaderBuffer-&gt;GetBufferSize(), NULL, &amp;m_pixelShader);
	if(FAILED(result))
	{
		return false;
	}

	// Create the vertex input layout description.
	polygonLayout[0].SemanticName = "POSITION";
	polygonLayout[0].SemanticIndex = 0;
	polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	polygonLayout[0].InputSlot = 0;
	polygonLayout[0].AlignedByteOffset = 0;
	polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[0].InstanceDataStepRate = 0;

	polygonLayout[1].SemanticName = "TEXCOORD";
	polygonLayout[1].SemanticIndex = 0;
	polygonLayout[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	polygonLayout[1].InputSlot = 0;
	polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[1].InstanceDataStepRate = 0;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
Our polygon layout is fairly different when using an instanced matrix.
We basically need to set four 32 bit floats for the four rows of the matrix.
We also set the input slot class to be instanced data.
The semantic index also needs to be incremented for each R32G32B32A32 because each is using WORLD.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	polygonLayout[2].SemanticName = "WORLD";
	polygonLayout[2].SemanticIndex = 0;
	polygonLayout[2].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	polygonLayout[2].InputSlot = 1;
	polygonLayout[2].AlignedByteOffset = 0;
	polygonLayout[2].InputSlotClass = D3D11_INPUT_PER_INSTANCE_DATA;
	polygonLayout[2].InstanceDataStepRate = 1;

	polygonLayout[3].SemanticName = "WORLD";
	polygonLayout[3].SemanticIndex = 1;
	polygonLayout[3].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	polygonLayout[3].InputSlot = 1;
	polygonLayout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[3].InputSlotClass = D3D11_INPUT_PER_INSTANCE_DATA;
	polygonLayout[3].InstanceDataStepRate = 1;

	polygonLayout[4].SemanticName = "WORLD";
	polygonLayout[4].SemanticIndex = 2;
	polygonLayout[4].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	polygonLayout[4].InputSlot = 1;
	polygonLayout[4].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[4].InputSlotClass = D3D11_INPUT_PER_INSTANCE_DATA;
	polygonLayout[4].InstanceDataStepRate = 1;

	polygonLayout[5].SemanticName = "WORLD";
	polygonLayout[5].SemanticIndex = 3;
	polygonLayout[5].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	polygonLayout[5].InputSlot = 1;
	polygonLayout[5].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[5].InputSlotClass = D3D11_INPUT_PER_INSTANCE_DATA;
	polygonLayout[5].InstanceDataStepRate = 1;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
This part of the polygon layout is for the instanced color.
It's also the second time we use the TEXCOORD semantic so we need to set the semantic index accordingly.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	polygonLayout[6].SemanticName = "TEXCOORD";
	polygonLayout[6].SemanticIndex = 1;
	polygonLayout[6].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	polygonLayout[6].InputSlot = 1;
	polygonLayout[6].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[6].InputSlotClass = D3D11_INPUT_PER_INSTANCE_DATA;
	polygonLayout[6].InstanceDataStepRate = 1;

	// Get a count of the elements in the layout.
	numElements = sizeof(polygonLayout) / sizeof(polygonLayout[0]);

	// Create the vertex input layout.
	result = device-&gt;CreateInputLayout(polygonLayout, numElements, vertexShaderBuffer-&gt;GetBufferPointer(), vertexShaderBuffer-&gt;GetBufferSize(), 
					   &amp;m_layout);
	if(FAILED(result))
	{
		return false;
	}

	// Release the vertex shader buffer and pixel shader buffer since they are no longer needed.
	vertexShaderBuffer-&gt;Release();
	vertexShaderBuffer = 0;

	pixelShaderBuffer-&gt;Release();
	pixelShaderBuffer = 0;

	// Setup the description of the dynamic matrix constant buffer that is in the vertex shader.
	matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	matrixBufferDesc.ByteWidth = sizeof(MatrixBufferType);
	matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	matrixBufferDesc.MiscFlags = 0;
	matrixBufferDesc.StructureByteStride = 0;

	// Create the constant buffer pointer so we can access the vertex shader constant buffer from within this class.
	result = device-&gt;CreateBuffer(&amp;matrixBufferDesc, NULL, &amp;m_matrixBuffer);
	if(FAILED(result))
	{
		return false;
	}

	// Create a texture sampler state description.
	samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.MipLODBias = 0.0f;
	samplerDesc.MaxAnisotropy = 1;
	samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
	samplerDesc.BorderColor[0] = 0;
	samplerDesc.BorderColor[1] = 0;
	samplerDesc.BorderColor[2] = 0;
	samplerDesc.BorderColor[3] = 0;
	samplerDesc.MinLOD = 0;
	samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;

	// Create the texture sampler state.
	result = device-&gt;CreateSamplerState(&amp;samplerDesc, &amp;m_sampleState);
	if(FAILED(result))
	{
		return false;
	}

	return true;
}


void FoliageShaderClass::ShutdownShader()
{
	// Release the sampler state.
	if(m_sampleState)
	{
		m_sampleState-&gt;Release();
		m_sampleState = 0;
	}

	// Release the matrix constant buffer.
	if(m_matrixBuffer)
	{
		m_matrixBuffer-&gt;Release();
		m_matrixBuffer = 0;
	}

	// Release the layout.
	if(m_layout)
	{
		m_layout-&gt;Release();
		m_layout = 0;
	}

	// Release the pixel shader.
	if(m_pixelShader)
	{
		m_pixelShader-&gt;Release();
		m_pixelShader = 0;
	}

	// Release the vertex shader.
	if(m_vertexShader)
	{
		m_vertexShader-&gt;Release();
		m_vertexShader = 0;
	}

	return;
}


void FoliageShaderClass::OutputShaderErrorMessage(ID3D10Blob* errorMessage, HWND hwnd, WCHAR* shaderFilename)
{
	char* compileErrors;
	unsigned long bufferSize, i;
	ofstream fout;


	// Get a pointer to the error message text buffer.
	compileErrors = (char*)(errorMessage-&gt;GetBufferPointer());

	// Get the length of the message.
	bufferSize = errorMessage-&gt;GetBufferSize();

	// Open a file to write the error message to.
	fout.open("shader-error.txt");

	// Write out the error message.
	for(i=0; i&lt;bufferSize; i++)
	{
		fout &lt;&lt; compileErrors[i];
	}

	// Close the file.
	fout.close();

	// Release the error message.
	errorMessage-&gt;Release();
	errorMessage = 0;

	// Pop a message up on the screen to notify the user to check the text file for compile errors.
	MessageBox(hwnd, L"Error compiling shader.  Check shader-error.txt for message.", shaderFilename, MB_OK);

	return;
}


bool FoliageShaderClass::SetShaderParameters(ID3D11DeviceContext* deviceContext, D3DXMATRIX viewMatrix, 
					     D3DXMATRIX projectionMatrix, ID3D11ShaderResourceView* texture)
{
	HRESULT result;
	D3D11_MAPPED_SUBRESOURCE mappedResource;
	MatrixBufferType* dataPtr;
	unsigned int bufferNumber;


	// Transpose the matrices to prepare them for the shader.
	D3DXMatrixTranspose(&amp;viewMatrix, &amp;viewMatrix);
	D3DXMatrixTranspose(&amp;projectionMatrix, &amp;projectionMatrix);

	// Lock the constant buffer so it can be written to.
	result = deviceContext-&gt;Map(m_matrixBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource);
	if(FAILED(result))
	{
		return false;
	}

	// Get a pointer to the data in the constant buffer.
	dataPtr = (MatrixBufferType*)mappedResource.pData;

	// Copy the matrices into the constant buffer.
	dataPtr-&gt;view = viewMatrix;
	dataPtr-&gt;projection = projectionMatrix;

	// Unlock the constant buffer.
	deviceContext-&gt;Unmap(m_matrixBuffer, 0);

	// Set the position of the constant buffer in the vertex shader.
	bufferNumber = 0;

	// Now set the constant buffer in the vertex shader with the updated values.
	deviceContext-&gt;VSSetConstantBuffers(bufferNumber, 1, &amp;m_matrixBuffer);

	// Set shader texture resource in the pixel shader.
	deviceContext-&gt;PSSetShaderResources(0, 1, &amp;texture);

	return true;
}


void FoliageShaderClass::RenderShader(ID3D11DeviceContext* deviceContext, int vertexCount, int instanceCount)
{
	// Set the vertex input layout.
	deviceContext-&gt;IASetInputLayout(m_layout);

	// Set the vertex and pixel shaders that will be used to render the geometry.
	deviceContext-&gt;VSSetShader(m_vertexShader, NULL, 0);
	deviceContext-&gt;PSSetShader(m_pixelShader, NULL, 0);

	// Set the sampler state in the pixel shader.
	deviceContext-&gt;PSSetSamplers(0, 1, &amp;m_sampleState);
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We are rendering instanced data so we need to use the DrawInstanced function.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Render the geometry.
	deviceContext-&gt;DrawInstanced(vertexCount, instanceCount, 0, 0);

	return;
}
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Applicationclass.h</u></font></p><pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: applicationclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _APPLICATIONCLASS_H_
#define _APPLICATIONCLASS_H_


/////////////
// GLOBALS //
/////////////
const bool FULL_SCREEN = true;
const bool VSYNC_ENABLED = true;
const float SCREEN_DEPTH = 100.0f;
const float SCREEN_NEAR = 0.1f;


///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "inputclass.h"
#include "d3dclass.h"
#include "shadermanagerclass.h"
#include "timerclass.h"
#include "positionclass.h"
#include "cameraclass.h"
#include "fpsclass.h"
#include "userinterfaceclass.h"
#include "modelclass.h"
#include "foliageclass.h"


////////////////////////////////////////////////////////////////////////////////
// Class name: ApplicationClass
////////////////////////////////////////////////////////////////////////////////
class ApplicationClass
{
public:
	ApplicationClass();
	ApplicationClass(const ApplicationClass&amp;);
	~ApplicationClass();

	bool Initialize(HINSTANCE, HWND, int, int);
	void Shutdown();
	bool Frame();

private:
	bool HandleMovementInput(float);
	bool Render();
	bool RenderSceneToTexture();

private:
	InputClass* m_Input;
	D3DClass* m_Direct3D;
	ShaderManagerClass* m_ShaderManager;
	TimerClass* m_Timer;
	PositionClass* m_Position;
	CameraClass* m_Camera;
	FpsClass* m_Fps;
	UserInterfaceClass* m_UserInterface;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We are using a simple plane as the ground model to render the foliage on.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	ModelClass* m_GroundModel;
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
This is our foliage object.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	FoliageClass* m_Foliage;
};

#endif
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Applicationclass.cpp</u></font></p><pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: applicationclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "applicationclass.h"


ApplicationClass::ApplicationClass()
{
	m_Input = 0;
	m_Direct3D = 0;
	m_ShaderManager = 0;
	m_Timer = 0;
	m_Position = 0;
	m_Camera = 0;
	m_Fps = 0;
	m_UserInterface = 0;
	m_GroundModel = 0;
	m_Foliage = 0;
}


ApplicationClass::ApplicationClass(const ApplicationClass&amp; other)
{
}


ApplicationClass::~ApplicationClass()
{
}


bool ApplicationClass::Initialize(HINSTANCE hinstance, HWND hwnd, int screenWidth, int screenHeight)
{
	bool result;

	
	// Create the input object.
	m_Input = new InputClass;
	if(!m_Input)
	{
		return false;
	}

	// Initialize the input object.
	result = m_Input-&gt;Initialize(hinstance, hwnd, screenWidth, screenHeight);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the input object.", L"Error", MB_OK);
		return false;
	}

	// Create the Direct3D object.
	m_Direct3D = new D3DClass;
	if(!m_Direct3D)
	{
		return false;
	}

	// Initialize the Direct3D object.
	result = m_Direct3D-&gt;Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize DirectX 11.", L"Error", MB_OK);
		return false;
	}

	// Create the shader manager object.
	m_ShaderManager = new ShaderManagerClass;
	if(!m_ShaderManager)
	{
		return false;
	}

	// Initialize the shader manager object.
	result = m_ShaderManager-&gt;Initialize(m_Direct3D, hwnd);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the shader manager object.", L"Error", MB_OK);
		return false;
	}

	// Create the timer object.
	m_Timer = new TimerClass;
	if(!m_Timer)
	{
		return false;
	}

	// Initialize the timer object.
	result = m_Timer-&gt;Initialize();
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the timer object.", L"Error", MB_OK);
		return false;
	}

	// Create the position object.
	m_Position = new PositionClass;
	if(!m_Position)
	{
		return false;
	}

	// Set the initial position.
	m_Position-&gt;SetPosition(0.0f, 1.5f, -4.0f);
	m_Position-&gt;SetRotation(15.0f, 0.0f, 0.0f);
	
	// Create the camera object.
	m_Camera = new CameraClass;
	if(!m_Camera)
	{
		return false;
	}

	// Set the initial position of the camera and build the matrices needed for rendering.
	m_Camera-&gt;SetPosition(0.0f, 0.0f, -10.0f);
	m_Camera-&gt;Render();
	m_Camera-&gt;RenderBaseViewMatrix();

	// Create the fps object.
	m_Fps = new FpsClass;
	if(!m_Fps)
	{
		return false;
	}

	// Initialize the fps object.
	m_Fps-&gt;Initialize();

	// Create the user interface object.
	m_UserInterface = new UserInterfaceClass;
	if(!m_UserInterface)
	{
		return false;
	}

	// Initialize the user interface object.
	result = m_UserInterface-&gt;Initialize(m_Direct3D, screenWidth, screenHeight);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the user interface object.", L"Error", MB_OK);
		return false;
	}
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
We create the ground model here.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Create the ground model object.
	m_GroundModel = new ModelClass;
	if(!m_GroundModel)
	{
		return false;
	}

	// Initialize the ground model object.
	result = m_GroundModel-&gt;Initialize(m_Direct3D-&gt;GetDevice(), "../Engine/data/plane01.txt", L"../Engine/data/rock015.dds");
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the ground model object.", L"Error", MB_OK);
		return false;
	}
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
And the foliage object is created here.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Create the foliage object.
	m_Foliage = new FoliageClass;
	if(!m_Foliage)
	{
		return false;
	}

	// Initialize the foliage object.
	result = m_Foliage-&gt;Initialize(m_Direct3D-&gt;GetDevice(), L"../Engine/data/grass.dds", 500);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the foliage object.", L"Error", MB_OK);
		return false;
	}

	return true;
}


void ApplicationClass::Shutdown()
{
	// Release the foliage object.
	if(m_Foliage)
	{
		m_Foliage-&gt;Shutdown();
		delete m_Foliage;
		m_Foliage = 0;
	}

	// Release the ground model object.
	if(m_GroundModel)
	{
		m_GroundModel-&gt;Shutdown();
		delete m_GroundModel;
		m_GroundModel = 0;
	}

	// Release the user interface object.
	if(m_UserInterface)
	{
		m_UserInterface-&gt;Shutdown();
		delete m_UserInterface;
		m_UserInterface = 0;
	}

	// Release the fps object.
	if(m_Fps)
	{
		delete m_Fps;
		m_Fps = 0;
	}

	// Release the camera object.
	if(m_Camera)
	{
		delete m_Camera;
		m_Camera = 0;
	}
	
	// Release the position object.
	if(m_Position)
	{
		delete m_Position;
		m_Position = 0;
	}

	// Release the timer object.
	if(m_Timer)
	{
		delete m_Timer;
		m_Timer = 0;
	}

	// Release the shader manager object.
	if(m_ShaderManager)
	{
		m_ShaderManager-&gt;Shutdown();
		delete m_ShaderManager;
		m_ShaderManager = 0;
	}

	// Release the Direct3D object.
	if(m_Direct3D)
	{
		m_Direct3D-&gt;Shutdown();
		delete m_Direct3D;
		m_Direct3D = 0;
	}

	// Release the input object.
	if(m_Input)
	{
		m_Input-&gt;Shutdown();
		delete m_Input;
		m_Input = 0;
	}

	return;
}


bool ApplicationClass::Frame()
{
	bool result;
	float posX, posY, posZ, rotX, rotY, rotZ;
	D3DXVECTOR3 cameraPosition;


	// Update the system stats.
	m_Timer-&gt;Frame();
	m_Fps-&gt;Frame();

	// Read the user input.
	result = m_Input-&gt;Frame();
	if(!result)
	{
		return false;
	}
	
	// Check if the user pressed escape and wants to exit the application.
	if(m_Input-&gt;IsEscapePressed() == true)
	{
		return false;
	}

	// Do the frame input processing.
	result = HandleMovementInput(m_Timer-&gt;GetTime());
	if(!result)
	{
		return false;
	}

	// Get the view point position/rotation.
	m_Position-&gt;GetPosition(posX, posY, posZ);
	m_Position-&gt;GetRotation(rotX, rotY, rotZ);

	// Do the frame processing for the user interface.
	result = m_UserInterface-&gt;Frame(m_Fps-&gt;GetFps(), posX, posY, posZ, rotX, rotY, rotZ, m_Direct3D-&gt;GetDeviceContext());
	if(!result)
	{
		return false;
	}
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
Each frame before rendering we need to update the rotation of the foliage using the camera position and the wind direction.
The wind direction is inside the foliage object.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Get the position of the camera.
	cameraPosition = m_Camera-&gt;GetPosition();

	// Do the frame processing for the foliage.
	result = m_Foliage-&gt;Frame(cameraPosition, m_Direct3D-&gt;GetDeviceContext());
	if(!result)
	{
		return false;
	}

	// Render the graphics.
	result = Render();
	if(!result)
	{
		return false;
	}

	return result;
}


bool ApplicationClass::HandleMovementInput(float frameTime)
{
	bool keyDown;
	float posX, posY, posZ, rotX, rotY, rotZ;


	// Set the frame time for calculating the updated position.
	m_Position-&gt;SetFrameTime(frameTime);

	// Handle the input.
	keyDown = m_Input-&gt;IsLeftPressed();
	m_Position-&gt;TurnLeft(keyDown);

	keyDown = m_Input-&gt;IsRightPressed();
	m_Position-&gt;TurnRight(keyDown);

	keyDown = m_Input-&gt;IsUpPressed();
	m_Position-&gt;MoveForward(keyDown);

	keyDown = m_Input-&gt;IsDownPressed();
	m_Position-&gt;MoveBackward(keyDown);

	keyDown = m_Input-&gt;IsAPressed();
	m_Position-&gt;MoveUpward(keyDown);

	keyDown = m_Input-&gt;IsZPressed();
	m_Position-&gt;MoveDownward(keyDown);

	keyDown = m_Input-&gt;IsPgUpPressed();
	m_Position-&gt;LookUpward(keyDown);

	keyDown = m_Input-&gt;IsPgDownPressed();
	m_Position-&gt;LookDownward(keyDown);
	
	// Get the view point position/rotation.
	m_Position-&gt;GetPosition(posX, posY, posZ);
	m_Position-&gt;GetRotation(rotX, rotY, rotZ);

	// Set the position of the camera.
	m_Camera-&gt;SetPosition(posX, posY, posZ);
	m_Camera-&gt;SetRotation(rotX, rotY, rotZ);

	return true;
}


bool ApplicationClass::Render()
{
	D3DXMATRIX worldMatrix, viewMatrix, projectionMatrix, orthoMatrix, baseViewMatrix;


	// Clear the scene.
	m_Direct3D-&gt;BeginScene(0.0f, 0.65f, 1.0f, 1.0f);

	// Generate the view matrix based on the camera's position.
	m_Camera-&gt;Render();

	// Get the matrices from the camera and d3d objects.
	m_Direct3D-&gt;GetWorldMatrix(worldMatrix);
	m_Camera-&gt;GetViewMatrix(viewMatrix);
	m_Direct3D-&gt;GetProjectionMatrix(projectionMatrix);
	m_Direct3D-&gt;GetOrthoMatrix(orthoMatrix);
	m_Camera-&gt;GetBaseViewMatrix(baseViewMatrix);

	// Render the ground model.
	m_GroundModel-&gt;Render(m_Direct3D-&gt;GetDeviceContext());
	m_ShaderManager-&gt;RenderTextureShader(m_Direct3D-&gt;GetDeviceContext(), m_GroundModel-&gt;GetIndexCount(), worldMatrix, viewMatrix, projectionMatrix, m_GroundModel-&gt;GetColorTexture());
</font></pre><p align="left"><font face="Arial" size="2" color="#FFFFFF">
Using alpha-to-coverage alpha blending is key to rendering the foliage correctly.
It handles the depth ordering transparency for us and is free of artifacts.
</font></p><pre><font face="arial" color="#aaffaa" size="2">	// Turn on the alpha-to-coverage blending.
	m_Direct3D-&gt;EnableAlphaToCoverageBlending();

	// Render the foliage.
	m_Foliage-&gt;Render(m_Direct3D-&gt;GetDeviceContext());
	m_ShaderManager-&gt;RenderFoliageShader(m_Direct3D-&gt;GetDeviceContext(), m_Foliage-&gt;GetVertexCount(), m_Foliage-&gt;GetInstanceCount(), viewMatrix, projectionMatrix, m_Foliage-&gt;GetTexture());

	// Turn off the alpha blending.
	m_Direct3D-&gt;TurnOffAlphaBlending();

	// Render the user interface.
	m_UserInterface-&gt;Render(m_Direct3D, m_ShaderManager, worldMatrix, baseViewMatrix, orthoMatrix);
	
	// Present the rendered scene to the screen.
	m_Direct3D-&gt;EndScene();

	return true;
}
</font></pre><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Summary</u></font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
So now we can render instanced foliage that has unique color, position, and rotation for each piece using just a single quad.
</font></p><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>To Do Exercises</u></font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
1. Compile and run the program.  Use the arrow keys and A, Z, PgUp, PgDn to examine the foliage.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
2. Modify the instanced color of the foliage.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
3. Increase and decrease the foliage count.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
4. Add another flower foliage object that is larger, has different animation speed, and is less in number (by modifying the FoliageClass to be more generic).
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
5. Add a static non-animated foliage such as small bushes.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
6. Add instancing for the size (scale) of each piece of foliage.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
7. Try the intersecting foliage method instead of the single quad to see the difference (make sure to turn off back face culling since you don't rotate it to face the camera).
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
8. Try a more advanced wind animation such as perlin noise to create gusts of wind in a field of grass.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
9. Setup a LOD for distance so that foliage is always rendered in the immediate area but not past 25 meters.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
10. Setup a density parameter so you can have low, medium, and high density levels of foliage (for low just render every 3rd foliage in the array, for medium every 2nd).
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
11. Implement the foliage in your own terrain engine; use a quad tree to determine the height to place each piece of foliage at.
</font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">
12. Create "foliage maps" similar to color maps, and place foliage randomly within the allowed color areas instead of giving each foliage a specific or completely random location on the terrain.
</font></p><br><p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Source Code</u></font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">Source Code and Data Files: <a href="http://www.rastertek.com/tersrc19.zip">tersrc19.zip</a></font></p><p align="left"><font face="Arial" size="2" color="#FFFFFF">Executable: <a href="http://www.rastertek.com/terexe19.zip">terexe19.zip</a></font></p><table align="center" border="0" width="1024"><tbody><tr>
















































































































































































































</tr></tbody></table>

<p align="center"><img border="0" src="./Tutorial 19_ Foliage_files/pic3002.gif" width="1024" height="1"></p>

<p align="center"><font face="Arial, Helvetica, sans-serif" size="2" color="#CCCCCC"><a href="http://www.rastertek.com/tutterr.html">Back to Tutorial Index</a></font></p>

</body><div id="cVim-status-bar" style="top: 0px;"></div><iframe src="./Tutorial 19_ Foliage_files/cmdline_frame.html" id="cVim-command-frame"></iframe></html>