
<!-- saved from url=(0039)http://www.rastertek.com/dx11tut26.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Tutorial 26: Transparency</title><style>#cVim-command-bar, #cVim-command-bar-mode, #cVim-command-bar-input, #cVim-command-bar-search-results,
.cVim-completion-item, .cVim-completion-item .cVim-full, .cVim-completion-item .cVim-left,
.cVim-completion-item .cVim-right {
  font-family: Helvetica, Helvetica Neue, Neue, sans-serif, monospace, Arial;
  font-size: 10pt !important;
  -webkit-font-smoothing: antialiased !important;
}

#cVim-command-bar {
  position: fixed;
  z-index: 2147483646;
  background-color: #1b1d1e;
  color: #bbb;
  display: none;
  box-sizing: content-box;
  box-shadow: 0 3px 3px rgba(0,0,0,0.4);
  left: 0;
  width: 100%;
  height: 20px;
}

#cVim-command-bar-mode {
  display: inline-block;
  vertical-align: middle;
  box-sizing: border-box;
  padding-left: 2px;
  height: 100%;
  width: 10px;
  padding-top: 2px;
  color: #888;
}

#cVim-command-bar-input {
  background-color: #1b1d1e;
  color: #bbb;
  height: 100%;
  right: 0;
  top: 0;
  width: calc(100% - 10px);
  position: absolute;
}

#cVim-command-bar-search-results {
  position: fixed;
  width: 100%;
  overflow: hidden;
  z-index: 2147483647;
  left: 0;
  box-shadow: 0 3px 3px rgba(0,0,0,0.4);
  background-color: #1c1c1c;
}

.cVim-completion-item, .cVim-completion-item .cVim-full, .cVim-completion-item .cVim-left, .cVim-completion-item .cVim-right {
  text-overflow: ellipsis;
  padding: 1px;
  display: inline-block;
  box-sizing: border-box;
  vertical-align: middle;
  overflow: hidden;
  white-space: nowrap;
}

.cVim-completion-item:nth-child(even) {
  background-color: #1f1f1f;
}

.cVim-completion-item {
  width: 100%; left: 0;
  color: #bcbcbc;
}

.cVim-completion-item[active] {
  width: 100%; left: 0;
  color: #1b1d1e;
  background-color: #f1f1f1;
}

.cVim-completion-item[active] span {
  color: #1b1d1e;
}

.cVim-completion-item .cVim-left {
  color: #fff;
  width: 37%;
}

.cVim-completion-item .cVim-right {
  font-style: italic;
  color: #888;
  width: 57%;
}


#cVim-link-container, .cVim-link-hint,
#cVim-hud, #cVim-status-bar {
  font-family: Helvetica, Helvetica Neue, Neue, sans-serif, monospace, Arial;
  font-size: 10pt !important;
  -webkit-font-smoothing: antialiased !important;
}

#cVim-link-container {
  position: absolute;
  pointer-events: none;
  width: 100%; left: 0;
  height: 100%; top: 0;
  z-index: 2147483647;
}

.cVim-link-hint {
  position: absolute;
  color: #302505 !important;
  background-color: #ffd76e !important;
  border-radius: 2px !important;
  padding: 2px !important;
  font-size: 8pt !important;
  font-weight: 500 !important;
  text-transform: uppercase !important;
  border: 1px solid #ad810c;
  display: inline-block !important;
  vertical-align: middle !important;
  text-align: center !important;
  box-shadow: 2px 2px 1px rgba(0,0,0,0.25) !important;
}

.cVim-link-hint_match {
  color: #777;
  text-transform: uppercase !important;
}


#cVim-hud {
  background-color: rgba(28,28,28,0.9);
  position: fixed !important;
  transition: right 0.2s ease-out;
  z-index: 24724289;
}

#cVim-hud span {
  padding: 2px;
  padding-left: 4px;
  padding-right: 4px;
  color: #8f8f8f;
  font-size: 10pt;
}

#cVim-frames-outline {
  position: fixed;
  width: 100%;
  height: 100%;
  left: 0;
  top: 0;
  right: 0;
  z-index: 9999999999;
  box-sizing: border-box;
  border: 3px solid yellow;
}
</style><link type="text/css" rel="stylesheet" href="chrome-extension://pioclpoplcdbaefihamjohnefbikjilc/content.css"></head>
<body text="#FFFFFF" bgcolor="#000000">

<p align="left"><font face="Arial" size="4" color="#FFFFFF"><b>
Tutorial 26: Transparency
</b></font></p>

<p align="left"><img border="0" src="./Tutorial 26_ Transparency_files/pic1001.gif" width="800" height="1"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Transparency is the effect that allows textured objects to appear see-through. For example take the following texture:
</font></p>

<p align="left"><img border="0" src="./Tutorial 26_ Transparency_files/pic0088.gif" width="256" height="256"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We can make it half transparent and then render it over another texture to create the following transparency effect:
</font></p>

<p align="left"><img border="0" src="./Tutorial 26_ Transparency_files/pic0089.gif" width="500" height="360"></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Transparency is implemented in DirectX 11 and HLSL by using alpha blending.
The alpha component of any pixel is used to determine the transparency of that pixel.  
For example if a pixel alpha value is 0.5 then it would appear half transparent.
Many textures have an alpha component that can be modified to make the texture transparent in some areas and opaque in others.
</font></p>
 
<p align="left"><font face="Arial" size="2" color="#FFFFFF">
However for alpha values to take effect you have to first turn on alpha blending in the shader and set the blending equation for how to blend pixels.
In this tutorial we modify the blending state in the D3DClass such as follows:
</font></p>
 
<pre><font face="arial" color="#FFFFFF" size="2">	blendStateDescription.RenderTarget[0].BlendEnable = TRUE;
	blendStateDescription.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
	blendStateDescription.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
</font></pre>
 
<p align="left"><font face="Arial" size="2" color="#FFFFFF">
DestBlend is for the destination color.
It is the pixel that already exists in this location.
The blending function we are going to use for the destination is INV_SRC_ALPHA which is the inverse of the source alpha.  
This equates to one minus the source alpha value.
For example if the source alpha is 0.3 then the dest alpha would be 0.7 so we will combine 70% of the destination pixel color in the final combine.
</font></p>
 
<p align="left"><font face="Arial" size="2" color="#FFFFFF">
SrcBlend is for the source pixel which will be the input texture color value in this tutorial.
The function we are going to use is SRC_ALPHA which is the source color multiplied by its own alpha value.  
</font></p>
 
<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The source and destination value will be added together to produce the final output pixel.
</font></p>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Framework</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The framework for this tutorial has a new class called TransparentShaderClass.
This class is the same as the TextureShaderClass except that is has a alpha blending value.
</font></p>

<p align="left"><img border="0" src="./Tutorial 26_ Transparency_files/pic0090.gif" width="575" height="253"></p>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>D3dclass.cpp</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
As discussed we have just modified the blend state inside the D3DClass::Initialize function so that texture transparency works.
This is the only change to that class.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Create an alpha enabled blend state description.
	blendStateDescription.RenderTarget[0].BlendEnable = TRUE;
	blendStateDescription.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
	blendStateDescription.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
	blendStateDescription.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
	blendStateDescription.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
	blendStateDescription.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
	blendStateDescription.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
	blendStateDescription.RenderTarget[0].RenderTargetWriteMask = 0x0f;
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparent.vs</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The transparent texture vertex shader is the same as the normal texture vertex shader.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparent.vs
////////////////////////////////////////////////////////////////////////////////


/////////////
// GLOBALS //
/////////////
cbuffer MatrixBuffer
{
    matrix worldMatrix;
    matrix viewMatrix;
    matrix projectionMatrix;
};


//////////////
// TYPEDEFS //
//////////////
struct VertexInputType
{
    float4 position : POSITION;
    float2 tex : TEXCOORD0;
};

struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
};


////////////////////////////////////////////////////////////////////////////////
// Vertex Shader
////////////////////////////////////////////////////////////////////////////////
PixelInputType TransparentVertexShader(VertexInputType input)
{
    PixelInputType output;
    

    // Change the position vector to be 4 units for proper matrix calculations.
    input.position.w = 1.0f;

    // Calculate the position of the vertex against the world, view, and projection matrices.
    output.position = mul(input.position, worldMatrix);
    output.position = mul(output.position, viewMatrix);
    output.position = mul(output.position, projectionMatrix);
    
    // Store the texture coordinates for the pixel shader.
    output.tex = input.tex;

    return output;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparent.ps</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparent.ps
////////////////////////////////////////////////////////////////////////////////


/////////////
// GLOBALS //
/////////////
Texture2D shaderTexture;
SamplerState SampleType;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We add a new constant buffer to hold the blendAmount variable.
The blendAmount indicates was percentage to blend the texture.
The acceptable value range is a float value from 0 to 1.  
In this tutorial it is set to 0.5 which means 50% transparency.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">cbuffer TransparentBuffer
{
    float blendAmount;
};


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
};


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 TransparentPixelShader(PixelInputType input) : SV_TARGET
{
    float4 color;
	
	
    // Sample the texture pixel at this location.
    color = shaderTexture.Sample(SampleType, input.tex);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Here we use the blendAmount variable to set the transparency of the texture.
We set the alpha value of the pixel to the blend amount and when rendered it will use the alpha value with the blend state we setup to 
create the transparency effect.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">    // Set the alpha value of this pixel to the blending amount to create the alpha blending effect.
    color.a = blendAmount;

    return color;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparentshaderclass.h</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The TransparentShaderClass is the same as the TextureShaderClass with some extra changes to accommodate transparency.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparentshaderclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _TRANSPARENTSHADERCLASS_H_
#define _TRANSPARENTSHADERCLASS_H_


//////////////
// INCLUDES //
//////////////
#include &lt;d3d11.h&gt;
#include &lt;d3dx10math.h&gt;
#include &lt;d3dx11async.h&gt;
#include &lt;fstream&gt;
using namespace std;


////////////////////////////////////////////////////////////////////////////////
// Class name: TransparentShaderClass
////////////////////////////////////////////////////////////////////////////////
class TransparentShaderClass
{
private:
	struct MatrixBufferType
	{
		D3DXMATRIX world;
		D3DXMATRIX view;
		D3DXMATRIX projection;
	};
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We have a new buffer type to match the constant buffer inside the pixel shader.
We add 12 bytes of padding so the CreateBuffer function won't fail.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	struct TransparentBufferType
	{
		float blendAmount;
		D3DXVECTOR3 padding;
	};

public:
	TransparentShaderClass();
	TransparentShaderClass(const TransparentShaderClass&amp;);
	~TransparentShaderClass();

	bool Initialize(ID3D11Device*, HWND);
	void Shutdown();
	bool Render(ID3D11DeviceContext*, int, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*, float);

private:
	bool InitializeShader(ID3D11Device*, HWND, WCHAR*, WCHAR*);
	void ShutdownShader();
	void OutputShaderErrorMessage(ID3D10Blob*, HWND, WCHAR*);

	bool SetShaderParameters(ID3D11DeviceContext*, D3DXMATRIX, D3DXMATRIX, D3DXMATRIX, ID3D11ShaderResourceView*, float);
	void RenderShader(ID3D11DeviceContext*, int);

private:
	ID3D11VertexShader* m_vertexShader;
	ID3D11PixelShader* m_pixelShader;
	ID3D11InputLayout* m_layout;
	ID3D11Buffer* m_matrixBuffer;
	ID3D11SamplerState* m_sampleState;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
We have a new buffer variable to provide an interface to the blendAmount value inside the transparent HLSL pixel shader.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	ID3D11Buffer* m_transparentBuffer;
};

#endif
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Transparentshaderclass.cpp</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: transparentshaderclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "transparentshaderclass.h"


TransparentShaderClass::TransparentShaderClass()
{
	m_vertexShader = 0;
	m_pixelShader = 0;
	m_layout = 0;
	m_matrixBuffer = 0;
	m_sampleState = 0;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Initialize the new transparent constant buffer to null inside the class constructor.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	m_transparentBuffer = 0;
}


TransparentShaderClass::TransparentShaderClass(const TransparentShaderClass&amp; other)
{
}


TransparentShaderClass::~TransparentShaderClass()
{
}


bool TransparentShaderClass::Initialize(ID3D11Device* device, HWND hwnd)
{
	bool result;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Load the transparent HLSL shader files.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Initialize the vertex and pixel shaders.
	result = InitializeShader(device, hwnd, L"../Engine/transparent.vs", L"../Engine/transparent.ps");
	if(!result)
	{
		return false;
	}

	return true;
}


void TransparentShaderClass::Shutdown()
{
	// Shutdown the vertex and pixel shaders as well as the related objects.
	ShutdownShader();

	return;
}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
The Render function now takes as input a blend float value which will set the amount of transparency to use in the shader.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">bool TransparentShaderClass::Render(ID3D11DeviceContext* deviceContext, int indexCount, D3DXMATRIX worldMatrix,
				    D3DXMATRIX viewMatrix, D3DXMATRIX projectionMatrix, ID3D11ShaderResourceView* texture, 
				    float blend)
{
	bool result;


	// Set the shader parameters that it will use for rendering.
	result = SetShaderParameters(deviceContext, worldMatrix, viewMatrix, projectionMatrix, texture, blend);
	if(!result)
	{
		return false;
	}

	// Now render the prepared buffers with the shader.
	RenderShader(deviceContext, indexCount);

	return true;
}


bool TransparentShaderClass::InitializeShader(ID3D11Device* device, HWND hwnd, WCHAR* vsFilename, WCHAR* psFilename)
{
	HRESULT result;
	ID3D10Blob* errorMessage;
	ID3D10Blob* vertexShaderBuffer;
	ID3D10Blob* pixelShaderBuffer;
	D3D11_INPUT_ELEMENT_DESC polygonLayout[2];
	unsigned int numElements;
	D3D11_BUFFER_DESC matrixBufferDesc;
	D3D11_SAMPLER_DESC samplerDesc;
	D3D11_BUFFER_DESC transparentBufferDesc;


	// Initialize the pointers this function will use to null.
	errorMessage = 0;
	vertexShaderBuffer = 0;
	pixelShaderBuffer = 0;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Load the transparent vertex shader.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Compile the vertex shader code.
	result = D3DX11CompileFromFile(vsFilename, NULL, NULL, "TransparentVertexShader", "vs_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 
				       0, NULL, &amp;vertexShaderBuffer, &amp;errorMessage, NULL);
	if(FAILED(result))
	{
		// If the shader failed to compile it should have writen something to the error message.
		if(errorMessage)
		{
			OutputShaderErrorMessage(errorMessage, hwnd, vsFilename);
		}
		// If there was  nothing in the error message then it simply could not find the shader file itself.
		else
		{
			MessageBox(hwnd, vsFilename, L"Missing Shader File", MB_OK);
		}

		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Load the transparent pixel shader.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Compile the pixel shader code.
	result = D3DX11CompileFromFile(psFilename, NULL, NULL, "TransparentPixelShader", "ps_5_0", D3D10_SHADER_ENABLE_STRICTNESS, 
				       0, NULL, &amp;pixelShaderBuffer, &amp;errorMessage, NULL);
	if(FAILED(result))
	{
		// If the shader failed to compile it should have writen something to the error message.
		if(errorMessage)
		{
			OutputShaderErrorMessage(errorMessage, hwnd, psFilename);
		}
		// If there was  nothing in the error message then it simply could not find the file itself.
		else
		{
			MessageBox(hwnd, psFilename, L"Missing Shader File", MB_OK);
		}

		return false;
	}

	// Create the vertex shader from the buffer.
	result = device-&gt;CreateVertexShader(vertexShaderBuffer-&gt;GetBufferPointer(), vertexShaderBuffer-&gt;GetBufferSize(), NULL, 
					    &amp;m_vertexShader);
	if(FAILED(result))
	{
		return false;
	}

	// Create the vertex shader from the buffer.
	result = device-&gt;CreatePixelShader(pixelShaderBuffer-&gt;GetBufferPointer(), pixelShaderBuffer-&gt;GetBufferSize(), NULL, 
					   &amp;m_pixelShader);
	if(FAILED(result))
	{
		return false;
	}

	// Create the vertex input layout description.
	// This setup needs to match the VertexType stucture in the ModelClass and in the shader.
	polygonLayout[0].SemanticName = "POSITION";
	polygonLayout[0].SemanticIndex = 0;
	polygonLayout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	polygonLayout[0].InputSlot = 0;
	polygonLayout[0].AlignedByteOffset = 0;
	polygonLayout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[0].InstanceDataStepRate = 0;

	polygonLayout[1].SemanticName = "TEXCOORD";
	polygonLayout[1].SemanticIndex = 0;
	polygonLayout[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	polygonLayout[1].InputSlot = 0;
	polygonLayout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
	polygonLayout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	polygonLayout[1].InstanceDataStepRate = 0;

	// Get a count of the elements in the layout.
	numElements = sizeof(polygonLayout) / sizeof(polygonLayout[0]);

	// Create the vertex input layout.
	result = device-&gt;CreateInputLayout(polygonLayout, numElements, vertexShaderBuffer-&gt;GetBufferPointer(), 
					   vertexShaderBuffer-&gt;GetBufferSize(), &amp;m_layout);
	if(FAILED(result))
	{
		return false;
	}

	// Release the vertex shader buffer and pixel shader buffer since they are no longer needed.
	vertexShaderBuffer-&gt;Release();
	vertexShaderBuffer = 0;

	pixelShaderBuffer-&gt;Release();
	pixelShaderBuffer = 0;

	// Setup the description of the dynamic constant buffer that is in the vertex shader.
	matrixBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	matrixBufferDesc.ByteWidth = sizeof(MatrixBufferType);
	matrixBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	matrixBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	matrixBufferDesc.MiscFlags = 0;
	matrixBufferDesc.StructureByteStride = 0;

	// Create the constant buffer pointer so we can access the vertex shader constant buffer from within this class.
	result = device-&gt;CreateBuffer(&amp;matrixBufferDesc, NULL, &amp;m_matrixBuffer);
	if(FAILED(result))
	{
		return false;
	}

	// Create a texture sampler state description.
	samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
	samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;
	samplerDesc.MipLODBias = 0.0f;
	samplerDesc.MaxAnisotropy = 1;
	samplerDesc.ComparisonFunc = D3D11_COMPARISON_ALWAYS;
	samplerDesc.BorderColor[0] = 0;
	samplerDesc.BorderColor[1] = 0;
	samplerDesc.BorderColor[2] = 0;
	samplerDesc.BorderColor[3] = 0;
	samplerDesc.MinLOD = 0;
	samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;

	// Create the texture sampler state.
	result = device-&gt;CreateSamplerState(&amp;samplerDesc, &amp;m_sampleState);
	if(FAILED(result))
	{
		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Setup the constant buffer interface to TransparentBuffer in the pixel shader which holds the blendAmount value.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Setup the description of the transparent dynamic constant buffer that is in the pixel shader.
	transparentBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
	transparentBufferDesc.ByteWidth = sizeof(TransparentBufferType);
	transparentBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	transparentBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
	transparentBufferDesc.MiscFlags = 0;
	transparentBufferDesc.StructureByteStride = 0;

	// Create the constant buffer pointer so we can access the pixel shader constant buffer from within this class.
	result = device-&gt;CreateBuffer(&amp;transparentBufferDesc, NULL, &amp;m_transparentBuffer);
	if(FAILED(result))
	{
		return false;
	}

	return true;
}


void TransparentShaderClass::ShutdownShader()
{
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Release the new transparent buffer in the ShutdownShader function.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Release the transparent constant buffer.
	if(m_transparentBuffer)
	{
		m_transparentBuffer-&gt;Release();
		m_transparentBuffer = 0;
	}

	// Release the sampler state.
	if(m_sampleState)
	{
		m_sampleState-&gt;Release();
		m_sampleState = 0;
	}

	// Release the matrix constant buffer.
	if(m_matrixBuffer)
	{
		m_matrixBuffer-&gt;Release();
		m_matrixBuffer = 0;
	}

	// Release the layout.
	if(m_layout)
	{
		m_layout-&gt;Release();
		m_layout = 0;
	}

	// Release the pixel shader.
	if(m_pixelShader)
	{
		m_pixelShader-&gt;Release();
		m_pixelShader = 0;
	}

	// Release the vertex shader.
	if(m_vertexShader)
	{
		m_vertexShader-&gt;Release();
		m_vertexShader = 0;
	}

	return;
}


void TransparentShaderClass::OutputShaderErrorMessage(ID3D10Blob* errorMessage, HWND hwnd, WCHAR* shaderFilename)
{
	char* compileErrors;
	unsigned long bufferSize, i;
	ofstream fout;


	// Get a pointer to the error message text buffer.
	compileErrors = (char*)(errorMessage-&gt;GetBufferPointer());

	// Get the length of the message.
	bufferSize = errorMessage-&gt;GetBufferSize();

	// Open a file to write the error message to.
	fout.open("shader-error.txt");

	// Write out the error message.
	for(i=0; i&lt;bufferSize; i++)
	{
		fout &lt;&lt; compileErrors[i];
	}

	// Close the file.
	fout.close();

	// Release the error message.
	errorMessage-&gt;Release();
	errorMessage = 0;

	// Pop a message up on the screen to notify the user to check the text file for compile errors.
	MessageBox(hwnd, L"Error compiling shader.  Check shader-error.txt for message.", shaderFilename, MB_OK);

	return;
}


bool TransparentShaderClass::SetShaderParameters(ID3D11DeviceContext* deviceContext, D3DXMATRIX worldMatrix, D3DXMATRIX viewMatrix, 
						 D3DXMATRIX projectionMatrix, ID3D11ShaderResourceView* texture, float blend)
{
	HRESULT result;
	D3D11_MAPPED_SUBRESOURCE mappedResource;
	MatrixBufferType* dataPtr;
	unsigned int bufferNumber;
	TransparentBufferType* dataPtr2;


	// Transpose the matrices to prepare them for the shader.
	D3DXMatrixTranspose(&amp;worldMatrix, &amp;worldMatrix);
	D3DXMatrixTranspose(&amp;viewMatrix, &amp;viewMatrix);
	D3DXMatrixTranspose(&amp;projectionMatrix, &amp;projectionMatrix);

	// Lock the matrix constant buffer so it can be written to.
	result = deviceContext-&gt;Map(m_matrixBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource);
	if(FAILED(result))
	{
		return false;
	}

	// Get a pointer to the data in the matrix constant buffer.
	dataPtr = (MatrixBufferType*)mappedResource.pData;

	// Copy the matrices into the matrix constant buffer.
	dataPtr-&gt;world = worldMatrix;
	dataPtr-&gt;view = viewMatrix;
	dataPtr-&gt;projection = projectionMatrix;

	// Unlock the buffer.
	deviceContext-&gt;Unmap(m_matrixBuffer, 0);

	// Set the position of the matrix constant buffer in the vertex shader.
	bufferNumber = 0;

	// Now set the matrix constant buffer in the vertex shader with the updated values.
	deviceContext-&gt;VSSetConstantBuffers(bufferNumber, 1, &amp;m_matrixBuffer);

	// Set shader texture resource in the pixel shader.
	deviceContext-&gt;PSSetShaderResources(0, 1, &amp;texture);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Here is where we set the blendAmount value inside the pixel shader before rendering.
We lock the transparent constant buffer, copy the blend amount value into the buffer, and then unlock it again so the shader can access the new value.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Lock the transparent constant buffer so it can be written to.
	result = deviceContext-&gt;Map(m_transparentBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &amp;mappedResource);
	if(FAILED(result))
	{
		return false;
	}

	// Get a pointer to the data in the transparent constant buffer.
	dataPtr2 = (TransparentBufferType*)mappedResource.pData;

	// Copy the blend amount value into the transparent constant buffer.
	dataPtr2-&gt;blendAmount = blend;

	// Unlock the buffer.
	deviceContext-&gt;Unmap(m_transparentBuffer, 0);

	// Set the position of the transparent constant buffer in the pixel shader.
	bufferNumber = 0;

	// Now set the texture translation constant buffer in the pixel shader with the updated values.
	deviceContext-&gt;PSSetConstantBuffers(bufferNumber, 1, &amp;m_transparentBuffer);

	return true;
}


void TransparentShaderClass::RenderShader(ID3D11DeviceContext* deviceContext, int indexCount)
{
	// Set the vertex input layout.
	deviceContext-&gt;IASetInputLayout(m_layout);

	// Set the vertex and pixel shaders that will be used to render this triangle.
	deviceContext-&gt;VSSetShader(m_vertexShader, NULL, 0);
	deviceContext-&gt;PSSetShader(m_pixelShader, NULL, 0);

	// Set the sampler state in the pixel shader.
	deviceContext-&gt;PSSetSamplers(0, 1, &amp;m_sampleState);

	// Render the triangle.
	deviceContext-&gt;DrawIndexed(indexCount, 0, 0);

	return;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Graphicsclass.h</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: graphicsclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _GRAPHICSCLASS_H_
#define _GRAPHICSCLASS_H_


/////////////
// GLOBALS //
/////////////
const bool FULL_SCREEN = true;
const bool VSYNC_ENABLED = true;
const float SCREEN_DEPTH = 1000.0f;
const float SCREEN_NEAR = 0.1f;


///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "d3dclass.h"
#include "cameraclass.h"
#include "modelclass.h"
#include "textureshaderclass.h"
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Include the header filer for the new TransparentShaderClass.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">#include "transparentshaderclass.h"


////////////////////////////////////////////////////////////////////////////////
// Class name: GraphicsClass
////////////////////////////////////////////////////////////////////////////////
class GraphicsClass
{
public:
	GraphicsClass();
	GraphicsClass(const GraphicsClass&amp;);
	~GraphicsClass();

	bool Initialize(int, int, HWND);
	void Shutdown();
	bool Frame();
	bool Render();

private:
	D3DClass* m_D3D;
	CameraClass* m_Camera;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Create two models for this tutorial.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	ModelClass* m_Model1;
	ModelClass* m_Model2;
	TextureShaderClass* m_TextureShader;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Create a TransparentShaderClass object.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	TransparentShaderClass* m_TransparentShader;
};

#endif
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Graphicsclass.cpp</u></font></p>

<pre><font face="arial" color="#aaffaa" size="2">////////////////////////////////////////////////////////////////////////////////
// Filename: graphicsclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "graphicsclass.h"
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Initialize the two models and the new TransparentShaderClass to null in the class constructor.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">GraphicsClass::GraphicsClass()
{
	m_D3D = 0;
	m_Camera = 0;
	m_Model1 = 0;
	m_Model2 = 0;
	m_TextureShader = 0;
	m_TransparentShader = 0;
}


GraphicsClass::GraphicsClass(const GraphicsClass&amp; other)
{
}


GraphicsClass::~GraphicsClass()
{
}


bool GraphicsClass::Initialize(int screenWidth, int screenHeight, HWND hwnd)
{
	bool result;

		
	// Create the Direct3D object.
	m_D3D = new D3DClass;
	if(!m_D3D)
	{
		return false;
	}

	// Initialize the Direct3D object.
	result = m_D3D-&gt;Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize Direct3D.", L"Error", MB_OK);
		return false;
	}

	// Create the camera object.
	m_Camera = new CameraClass;
	if(!m_Camera)
	{
		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Create and initialize the first model which will be a square with a dirt texture on it.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Create the first model object.
	m_Model1 = new ModelClass;
	if(!m_Model1)
	{
		return false;
	}

	// Initialize the first model object.
	result = m_Model1-&gt;Initialize(m_D3D-&gt;GetDevice(), L"../Engine/data/dirt01.dds", "../Engine/data/square.txt");
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the first model object.", L"Error", MB_OK);
		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Create and initialize the second model which will be a square with a stone texture on it.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Create the second model object.
	m_Model2 = new ModelClass;
	if(!m_Model2)
	{
		return false;
	}

	// Initialize the second model object.
	result = m_Model2-&gt;Initialize(m_D3D-&gt;GetDevice(), L"../Engine/data/stone01.dds", "../Engine/data/square.txt");
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the second model object.", L"Error", MB_OK);
		return false;
	}

	// Create the texture shader object.
	m_TextureShader = new TextureShaderClass;
	if(!m_TextureShader)
	{
		return false;
	}

	// Initialize the texture shader object.
	result = m_TextureShader-&gt;Initialize(m_D3D-&gt;GetDevice(), hwnd);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the texture shader object.", L"Error", MB_OK);
		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Create and initialize the new TransparentShaderClass object.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Create the transparent shader object.
	m_TransparentShader = new TransparentShaderClass;
	if(!m_TransparentShader)
	{
		return false;
	}

	// Initialize the transparent shader object.
	result = m_TransparentShader-&gt;Initialize(m_D3D-&gt;GetDevice(), hwnd);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize the transparent shader object.", L"Error", MB_OK);
		return false;
	}

	return true;
}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Release the new TransparentShaderClass object and two model objects in the Shutdown function.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">void GraphicsClass::Shutdown()
{
	// Release the transparent shader object.
	if(m_TransparentShader)
	{
		m_TransparentShader-&gt;Shutdown();
		delete m_TransparentShader;
		m_TransparentShader = 0;
	}

	// Release the texture shader object.
	if(m_TextureShader)
	{
		m_TextureShader-&gt;Shutdown();
		delete m_TextureShader;
		m_TextureShader = 0;
	}

	// Release the second model object.
	if(m_Model2)
	{
		m_Model2-&gt;Shutdown();
		delete m_Model2;
		m_Model2 = 0;
	}

	// Release the first model object.
	if(m_Model1)
	{
		m_Model1-&gt;Shutdown();
		delete m_Model1;
		m_Model1 = 0;
	}

	// Release the camera object.
	if(m_Camera)
	{
		delete m_Camera;
		m_Camera = 0;
	}

	// Release the D3D object.
	if(m_D3D)
	{
		m_D3D-&gt;Shutdown();
		delete m_D3D;
		m_D3D = 0;
	}

	return;
}


bool GraphicsClass::Frame()
{
	// Set the position of the camera.
	m_Camera-&gt;SetPosition(0.0f, 0.0f, -5.0f);

	return true;
}


bool GraphicsClass::Render()
{
	D3DXMATRIX worldMatrix, viewMatrix, projectionMatrix;
	bool result;
	float blendAmount;
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Setup a blend variable that will be sent into the transparent shader.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Set the blending amount to 50%.
	blendAmount = 0.5f;

	// Clear the buffers to begin the scene.
	m_D3D-&gt;BeginScene(0.0f, 0.0f, 0.0f, 1.0f);

	// Generate the view matrix based on the camera's position.
	m_Camera-&gt;Render();

	// Get the world, view, and projection matrices from the camera and d3d objects.
	m_D3D-&gt;GetWorldMatrix(worldMatrix);
	m_Camera-&gt;GetViewMatrix(viewMatrix);
	m_D3D-&gt;GetProjectionMatrix(projectionMatrix);
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Render the first square model with the dirt texture in the center of the screen. Use just the regular texture shader for this.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Put the model vertex and index buffers on the graphics pipeline to prepare them for drawing.
	m_Model1-&gt;Render(m_D3D-&gt;GetDeviceContext());

	// Render the model with the texture shader.
	result = m_TextureShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_Model1-&gt;GetIndexCount(), worldMatrix, viewMatrix,
					 projectionMatrix, m_Model1-&gt;GetTexture());
	if(!result)
	{
		return false;
	}
</font></pre>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
Render the second square model with the stone texture slightly to the right and above the previous square texture. 
Use the new TransparentShaderClass object with the blendAmount input to render the square stone texture with transparency so we can see through it.
Also turn on the alpha blending from the D3DClass before rendering and then turn it off after rendering.
</font></p>

<pre><font face="arial" color="#aaffaa" size="2">	// Translate to the right by one unit and towards the camera by one unit.
	D3DXMatrixTranslation(&amp;worldMatrix, 1.0f, 0.0f, -1.0f);

	// Turn on alpha blending for the transparency to work.
	m_D3D-&gt;TurnOnAlphaBlending();

	// Put the second square model on the graphics pipeline.
	m_Model2-&gt;Render(m_D3D-&gt;GetDeviceContext());

	// Render the second square model with the stone texture and use the 50% blending amount for transparency.
	result = m_TransparentShader-&gt;Render(m_D3D-&gt;GetDeviceContext(), m_Model2-&gt;GetIndexCount(), worldMatrix, viewMatrix,
					     projectionMatrix, m_Model2-&gt;GetTexture(), blendAmount);
	if(!result)
	{
		return false;
	}

	// Turn off alpha blending.
	m_D3D-&gt;TurnOffAlphaBlending();

	// Present the rendered scene to the screen.
	m_D3D-&gt;EndScene();

	return true;
}
</font></pre>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Summary</u></font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
With transparency we can create see through textures and models which allows us to create a number of different effects.
</font></p>

<p align="left"><img border="0" src="./Tutorial 26_ Transparency_files/pic0089.gif" width="500" height="360"></p>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>To Do Exercises</u></font></p>
 
<p align="left"><font face="Arial" size="2" color="#FFFFFF">
1. Recompile the and run the program.  Press escape to quit.
</font></p>

<p align="left"><font face="Arial" size="2" color="#FFFFFF">
2. Change the value of the blendAmount in the GraphicsRender function to see different amounts of transparency.
</font></p>

<br>
<p align="left"><font face="Arial" size="3" color="#FFFFFF"><u>Source Code</u></font></p>
<p align="left"><font face="Arial" size="2" color="#FFFFFF">Visual Studio 2008 Project: <a href="http://www.rastertek.com/dx11tut26.zip">dx11tut26.zip</a></font></p>
<p align="left"><font face="Arial" size="2" color="#FFFFFF">Source Only: <a href="http://www.rastertek.com/dx11src26.zip">dx11src26.zip</a></font></p>
<p align="left"><font face="Arial" size="2" color="#FFFFFF">Executable Only: <a href="http://www.rastertek.com/dx11exe26.zip">dx11exe26.zip</a></font></p>

<p align="left"><img border="0" src="./Tutorial 26_ Transparency_files/pic1002.gif" width="800" height="1"></p>
<p align="left"><font face="Arial, Helvetica, sans-serif" size="2" color="#CCCCCC"><a href="http://www.rastertek.com/tutindex.html">Back to Tutorial Index</a></font></p>
</body><div id="cVim-status-bar" style="top: 0px;"></div><iframe src="./Tutorial 26_ Transparency_files/cmdline_frame.html" id="cVim-command-frame"></iframe></html>