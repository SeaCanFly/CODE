#include<stdio.h>
int gcd(int a, int b)
{
	int temp;
	while (b)
	{
		/*求最小公约数,利用辗除法，直到b为0为止*/
		temp = b;			
		b = a % b;			//若a<b，a%b=a，即实现a和b的对调
		a = temp;
	}
	return a;
}
int main()
{
	/*
		{}:
			表示stack[栈],执行完毕后,{}内的除了:局部全局,堆数据[heap],全局数据.其余的全部会自动删除
	*/
	/*
		void func1(int a)
		void func2(int* a)
		void func3(int** a)
		int main()
		{
			int b1;
			int* b2;
			int** b3
			struct* T;
			func1(b1);
			func2(b2);
			func3(b3);
		}
			函数的参数传递,就是在函数的stack空间创建一块新的内存空间,复制内容到这块空间(内容一样,存内容的地址不一样)
			所以要想对传进的参数同时影响到外部的话,在函数内部改这块空间里的内容是无效的
			同时可以任意修改这些内容而不会影响到外部,但要注意和谨慎使用new与malloc[须在函数结束前释放内存]
			比如在函数里:
			int谨慎或不要修改int内容[a=3]
			int*谨慎或不要修改指针的指向[a=&c/a=malloc/a=new等],因为修改的仅仅是函数stack内的a的指针地址,所以分配的内存的指针仅仅在函数内部[并不是外部传进来的指针指向的内存]所以要使用的话,必须把函数内部的指针传出,或者函数结束前释放内存!
			int**谨慎不要修改二级指针的指向,但要特别注意谨慎二级指针指向的一级指针是和外部是相同的内存和内容,所以修改一级指针时[*a=&b/*a=malloc/*a=new]会同时作用于外部,可以实现对外部的分配heap内存和重新指向
			struct* T对于结构体同样,注意一点,同样是拷贝*T,但内部的指针和变量指向的是源地址和内容[函数外部的]
			struct T拷贝的是整个结构体,所以内部的指针和变量指向的是函数内复制过来的结构体的[函数stack上的]地址和内容
	*/
	/*
		static:
				只能在声明的范围内看到的长期[全局](但是局部全局)，编译后就存在在内存中，在code区。
				static int a;
				static int b()
				{
					static int c;
					static int d(){}
				}
				class E
				{
				public:
					static int f;
					static int g(){}
				}i;
				a,b:只能在该文件内看到,为该文件的全局变数、全局函数,其他文件无法访问。
				c,d:在b函数中可以看到、访问,外部无法看到。
				f,g:是class E的局部全局,用E::f,E::g(),i.f,i.g()等局部全局来访问,或通过实体访问
				因为这些变量和函数在编译前就存在内存中,所以这些都无this指针等，

	*/
	/*
		reinterpret_cast<type>:	和c语言的(type)强制转换一样
		static_cast<type>:		已确定继承关系的down-casting
		dynamic_cast<type>:		判断是否有继承关系,没有返回0
		const_cast<type>:		const类型的转换

	*/
	/*
		class E
		{
		public:
			virtual void fun(){}	虚函数；
			virtual void fun()=0;	纯虚函数；
			virtual ~E(){}			虚析构函数；
		}
		virtual表示虚拟,即表示指向该实体中相同虚函数中的最后一个,也就是自身实体所定义的那个函数。
				虚函数可以构造实体,但纯虚函数因为无函数实体,所以无法构造实体
				若有虚函数,则析构函数必须为虚函数,否则无法正常析构
				若有up-casting时,即使base class里没有虚函数,也需要加上虚析构函数,否则在析构时会调用base class的析构函数而无法正确调用derived class的析构函数

	*/
	/*
		char			%c
		shor			%hd
		int				%d[%i]
		long			%ld
		long long		%lld[%I64d]
		float			%f[%e][%g]
		double			%lf[%le][%lg]
		long double		%Lf[%Le][%Lg]
		string			%s
	*/
	/* 
		高字节兼容低字节
		%hhd，%hhu，%hho，%hhx， 限定为一个字节，char型的d，u，o，x。
		%hd，%hu，%ho，%hx，		限定为两个字节，short型的d，u，o，x。
		%d，%u，%o，%x，			
		%ld，%lu，%lo，%lx		限定为四或八个字节，long型的d，u，o，x。
		%lld，%llu，%llo，%llx	限定为sizeof(long long)型的d，u，o，x。
		%Lf，%Le，%Lg			限定为sizeof(long double)型的d，u，o，x。
	*/
	/*
	Tip：只要在不同的大括号区域[不分函数相同与不同]，就可以定义相同名字的变量，但是他们只是名字相同，地址并不同！
		在不同的大括号中，该变量只存在在该大括号中，直到大括号运行结束该变量消失[static类型除外]！
		所以不存在内部括号屏蔽外部括号，因为只是名字相同，它们不是一个地址，在大括号内用这个变量，只是用该大括号内的变量，并不是调用外部同名的变量。
		若内部大括号无重名，则可以调用大括号外部的变量[必须在一个体系内]，括号外的变量可继承到下层大括号。
		所以同理，在函数定义的数组，在返回首地址后，在栈空间的
		数组会随着大括号运行的结束而消失，所以得不到该数组，函数要想返回多个数值和数组，可以用struct结构体封装返回。
	*/
	/*printf
	Tip：printf打印的控制台，内部全是0和1，%d，%c，%f，只是用不同的角度去解析显示，但不同类型储存方式不一样，长度不一，格式也不一.
		printf函数的返回值为输出字符的个数。
			printf("%-0*.* s",i,i);printf("%-0*.* f",i,i);printf("%-0* d",i)等等，可以用变量i来控制星号制表
			－号表示左对齐，.号之前的*表示输出多少字符，，少于*号正常输出，多于*号的话，0*表示空白用0填充，*表示用空白填充
			若加空格，如% d/f，则若为正数的话，多出一个空格，对负数无影响。
			若加+，如%+d/f,则若为正数前加上+，负数不受影响。
			若加#，%#.f/e/g,则保证显示小数点，%#x,%#o,可以显示进制前缀
			printf函数不会去做转换，所以储存和读取数据，需注意类型匹配，否则储存和读取数据会不一致。
			printf("xxxx%n,x),%n表示，把%n之前的字符串长度[此长度为纯长度，不包含'\0']保存到x变量中，该语句vs中可能已被禁用.
			printf("%i",x)%i和%d一样，输出有符号十进制整数。
			printf("%a%A",float1,float2)%a与%A[输出大小写之分]是C99里的16进制浮点数记数法
		puts("xxxx");	puts输出字符串，会自动在末尾加入\n.
		putchar('x');   putchar输出一个字符，putchar(x),x可以是变量，可以是常量(数字)
	*/
	/*scanf
	Tip:scanf为扫描转换输入流[从stdin中扫描，即用户输入]，按下回车才会开始扫描，扫描遇到该类型会取出数据，遇到错误或不匹配的类型，不会跳过，会一直扫描此不匹配的数据，后面的就无法扫描到。
		scanf函数的返回值为成功扫描数据的个数。有多少个变量被赋值
			scanf("%*md",x),*为略过[输入后不赋值给变量]，m为只取m个，其中x为指针[即地址]，
			scanf("%n.mf",x)是错误的，scanf不会精度控制。
			scanf("%c",&x)需要特别注意，因为扫描的是字符类型，回车也会被当作字符被扫描到。所以循环扫描字符时
			最好为scanf(" %c",&x)，或getchar(),或清空缓存：int c;while ((c = getchar()) != '\n'&&c != EOF);
			scanf("%s",x)扫描字符串，遇到空白键就会停止扫描。
			scanf("%d%n",&num,&x)这里的%n可以统计总共输入了多少个字符，然后赋值给变量x。
			scanf("%i",&x)%i和%d基本一样，但%i能够获得8/16进制的十进制的值，比如0011就是9，0x11就是17
			scanf("%m[^xxx],&x),其中m为扫描多少，若有^[可以理解为直到]，应放第一位，[^xxx]表示遇到x，x，x其中一个才停止扫描，
			[a-z][0-9][A-Z][0-9,a-z]表示只扫描该类型的数据，一旦没有扫描到就停止，不跳过扫描，也就是不进行后续扫描。
			所以可以用scanf("%[^\n]",str)来接收带有空格的字符串。
			解决扫描类型不匹配引起的崩溃，判断函数返回值来用while循环除错，要执行的语句放到while循环之后
			while(scanf("%d%d",&a,&b)!=2) 
			{int c;while ((c = getchar()) != '\n'&&c != EOF);}+code

		gets()函数由于gets()无法知道字符串的大小，必须遇到换行字符或文件尾才会结束输入。
			scanf ：未设定限制符[^x]时，当遇到回车，空格和tab键会自动在字符串后面添加'\0'，结束扫描，但是回车，空格和tab键仍会留在输入的缓冲区中。
			gets：可接受回车键之前输入的所有字符，并用'\n'替代 '\0'.回车键不会留在输入缓冲区中
		getchar()返回值是int型，是第一个字符的二进制编码的int型，出错返回-1
	*/
	/*sprintf
	sprintf函数是将数据打印到字符串，与printf比只是最前面多了个到打印的字符串地址。
	sprintf的返回值是最终打印到字符缓冲区中的字符数目，
	返回写入buffer 的字符数，出错则返回-1. 如果 buffer 或 format 是空指针，且不出错而继续，函数将返回-1，并且 errno 会被设置为 EINVAL。
	sprintf 返回被写入buffer 的字节数，结束字符‘\0’不计入内。
		int	sprintf(char *buffer, const char *format [, argument] ... )
		第一个[buffer]表示要输入进去的字符串指针，第二个[format]为转换格式，第三[argument]为被转换的量。
				[format]%[参数][标识符][宽度][.精度]指示符
					若想输出'%'本身时, 请使用'%%'处理。
					1. 参数：处理字符方向。负号时表示从后向前处理，也可以理解左对齐或右对齐。
					2. 标识符：填空字元。 0 的话表示空格填 0；空格是内定值，表示空格就放着。
					3. 宽度：字符总宽度。为最小宽度。
					4. 精度：精确度，小数点后的浮点数位数，字符串位数。
			sprintf(s, "%.6s%.5s", a1, a2) 连接字符串a1的6个字符与字符串a2的5个字符到s
			int len = sprintf(s, "%d", i)	把整型i打印到s，利用返回值计算整数的位数
	*/
	/*sscanf
	sscanf函数是将一段字符串扫描出来，然后转换。
	sscanf的返回值是有多少个变量被赋值
		int sscanf( const char *buffer, const char *format [, argument ] ... )
		一[buffer]表示要被扫描的字符串指针，二[format]为要扫描与转换的格式，三[argument]为扫描出来的数据要保存的地方。
		sscanf(ch,"%*[^e]%[^2]",ch1);寻找e到2之间的数，包括e但不包括2，如果中间有空格，包括空格。
		sscanf(ch,"%*s%d",&total); *号表示忽略该段，%*s为忽略该字符串到空白键。
		sscanf("2006:03:18", "%d:%d:%d", a, b, c);
		sscanf("2006:03:18 - 2006:04:18", "%s - %s", sztime1, sztime2);
		sscanf("2006:03:18 - 2006:04:18", "%[0-9,:] - %[0-9,:]", sztime1, sztime2);
	*/
//0
printf("1--数据在内存的高位与低位\n>\n");
	int x = 1;							
	if (*(char*)&x == 1)			
	{							
		printf("高位在前\n");		  
	}
	else
	{
		printf("高位在后\n");
	}
	printf("\n");
//1
printf("2--逗号运算符\n>\n");
	int d = (1, 2);
	printf("d=%d\n", d);//d=2,逗号运算符，优先度最低，从左到右，
	d = ((d = 3, d * 3), d + 3);
	printf("d=%d\n", d);//d=6
	d = (3 * 5, d * 4), d + 5;//d+5为歧义书写，未赋值，只是加五
	printf("d=%d\n", d);//d=24
	printf("\n");
//2
printf("3--关系运算符\n>\n");
	printf("1<3<2:%d\n", 1 < 3 < 2 == 1);
	printf("3>2>1:%d\n", 3 > 2 > 1);
	printf("3==3==3:%d\n", 3 == 3 == 1);
	printf("3==3==2:%d\n", 3 == 3 == 2);
	printf("5!=5==0:%d\n", 5 != 5 == 0);
	printf("5!=5==1:%d\n", 5 != 5 == 1);/*从左到右，判断式正确为1，错误为0,不仅如此，
	所有的判断：if_else的判断，是判断是0还是非0，加上&&与||与！等条件之后的判断式会返回结果为1，或0，然后编译器用1(非0/正确/运行)和0(错误/跳过)来作为判断标准。*/
	printf("\n");
//3
printf("4--对数据类型去反!\n>\n");
	char string[] ="xyz";
	char ch = 'a';
	int num1 = -4;
	int num2 = 0;
	printf("num1=%d,!num1=%d\nnum2=%d,!num2=%d\n", num1, !num1, num2, !num2);
	printf("string=%s,!string=%s\nc=%c,!c=%c\n", string, !string,ch,!ch);
	/*
		！type 对一个变量，字符串取！就是让其变为'\0'，NULL，数字则表现为0；
		若数字型变量num=0，则！num=1
	*/
	printf("\n");
//4
printf("5--数据类型的提升[字节的增多]\n>\n");
	char ch1 = 'A';
	char ch2 = 'B';
	printf("'A='%d,ch1=%d,ch1+ch2=%d\n", sizeof('A'), sizeof(ch1),sizeof(ch1+ch2));//提升字节
	printf("\n");
//5
printf("6--数据丢失[四舍五入相关]\n>\n");
	int a = 1.9;
	int b = 1.5f;
	printf("a=%d,b=%d\n", a, b);//浮点转换int，直接斩掉后面数据，不进行四舍五入等运算判断，但用printf("%.nf",xx)的.n的时候进行四舍五入。
	printf("\n");
	/*
	Tip：浮点数float在内存中的表示[1,8,23]，[32bit]内存分三段，[一段:1]第一位表数正负，[二段:8]后八位存指数，[三段:23]后面存二进制后的小数部分。
		double内存中表示为[1,11,52],要是64位的，长度会不同。
	一.	先把浮点数转换成二进制，整数部分/2取余数(%2)[2^n...2^0]，小数部分*2取进数[2^-1...2^-n]，然后移动小数点成1.010111*2^x的样式[首位为1]。
	二.	二进制小数部分[010111]顶头放到三段，后面补零。二进制指数部分[x]+127转换为二进制后，放到二段，之所以加127，是为了只存正数，加的大小跟二段的长度有关。
		因为二段2^128，2^1024，所以float范围-3.40E+38 ~ +3.40E+38，double范围-1.79E+308 ~ +1.79E+308。二段决定范围。
		因为三段2^23，2^52，所以float只精确到小数点6，浮摆到7位，double可以精确到15，浮摆到16位。三段决定精度。
	*/
//6
printf("7--字符指针\n>\n");
	//字符指针和字符串数组的赋值和修改内容:
			/*
				指针储存的都是相应数据类型的首地址
				因为指针储存的是地址，所以任何类型的指针大小都一样，理论上指针大小跟寻址能力和内存大小有关，32位电脑指针大小一般也是32位。
				所有的指针储存的地址都是首地址，然后编译器和系统根据指针的类型来决定指针的下一个指向向后走多少个bit位。
			*/
	/*
		tips:int型数组或char型数组末尾可以没有NULL，但字符串必须有NULL，字符串数组长度比字符串大壹
		所以用while循环遍历数组时，x[]！=NULL会有所不同,用for循环需要先测量数组到NULL的长度
	*/
	char *str="abcd";
	printf("%s\n", str);
	str = "kshyh";			//指针指向字符串，指针可以修改，但内容不能修改
	printf("%s\n", str);
	int i = 0;
	while (str[i]!=NULL)
	{
		printf("%c", str[i++]);	//指针指向字符串，字符串数组，数组，该指针就相当于数组，则也可以用数组的方式去代替指针操作。
	}
	printf("\n");
    //str[0] = 'a';错误，字符串在常量区，无法修改，但是可以打印
	/*
		char *a;
		a="cool";
			 这是地址赋值，将一个常量字符串的首地址赋值给a这个指针。字符串常量可以通过多个指针指向该字符串常量，然后比较地址来比较，
			 但字符串变量需要用函数比较。
		*a = "cool";
			 这是字符赋值，不是字符串！虽然a叫字符串指针，但char* a这样的定义，*a必然是一个字符，而不是多个。
			 因此后面的常量会被忽略为一个字符，进行数值赋值（也可以理解为拷贝赋值，区别于地址赋值）。
			 在a没有分配地址的情况下，直接 *a = “xxx” 会造成内存报错，而a = ""则不会。
	*/
//7
printf("8--字符数组\n>\n");
char s[10] = { NULL };
	/*
		char s[10]="xxx"; 初始化时可以，在定义时用=号代表初始化声明和定义字符串数组
		但
		char s[10];
		s[10]="xxx";	  错误，s[10]不存在，并且"xxx"是字符串，而s[]是char类型
		s="xxx";		  错误，s是s[]的首地址，已经指向数组s[](所以为常指针)，又赋值字符串"xxx"的首地址，s双指向错误
		s[0]='x'		  可以赋值修改，因为字符数组储存在栈区，所以内容可以修改
		scanf("%s",s)	  可以用scanf函数修改
		while(s[10]!=NULL)可以用while，for等循环修改赋值，因为s[0]='x'可以修改
						  也还可以用strcpy，strcat等函数修改
	*/
	scanf("%9[^\n]", s);//读入长度为10[0-9]的字符串，如果不到10,遇到\n, 读入结束
	printf("1%s\n2", s);
	puts(s);
	char* pstr = s;
	while (*pstr!= NULL)		//tip！易犯错误，此处应为*pstr，内容指向NULL停止，而不是pstr，pstr指向的是地址数据，而且不可以是常指针。
	{								//在while(*pstr++ != NULL),因为自增了之后再打印，所以第一个数据不会输出，可以用此过滤首数据。
		printf("%c", *pstr++);	//用指针去操作数组
	}
	printf("\n");
	printf("getchar:%c\n", getchar());//用scanf("%num[^\n]", s)多出的部分会溢出，溢出的部分进入缓冲区
	char c;int c;
	while ((c = getchar()) != '\n'&&c != EOF);//清空缓冲区
	/*
		int a[n];
		p=a;
			每次p++增加 1*sizeof(int)字节，a为a[n]的首地址，即a[0]。
		-----------------------------------
		int (*p)[n]; //是指针，指向数组，数组作为一个整体
		数组指针
			表示：指向数组p的指针
			元素表示：(*p)[i]
			每次p++增加 n*sizeof(int)字节
	-----------------------------------
		int* p[n]     //是数组，指针的数组
		指针数组
			表示：数组a中的元素内容都为int型指针
			元素表示：*p[i]   
			*(p[i])是一样的，因为[]优先级高于*
	----------------------------------------
		char* c = (char*)a;
		c++表示地址加一，8个bit的长度
	---------------------------------------
	int a=1;
	const int* p1=&a；				//p1可变[p1可转向],*p1不可变，此时不能用*p1来修改a的内容，但是a的值可以变[a=2]
	int* const p2=&a；				//p2不可变[不可转向],*p2可变[*p2=2],a的值可变[a=2]
	int const* p3=&a				//p3可变[p4可转向],*p3不可变,a的值可变[a=2]
	const int* const p4=&a；			//p4不可变[不可转向],*p4不可变,a的值可变[a=2]
	const int const *p5=&a				//p5可变[p5可转向],*p5不可变,a的值可变[a=2]
	

	tip：void function()const{};		//常成员函数, 它不改变对象的成员变量.也不能调用类中任何非const成员函数。
	*/
	/*
	用二维数组char a[n][MAX]可以定义字符串型的数组，然后就可以用循环来进行输入输出
	for (int i = 0; i < n; i++)
	{
		scanf("%s", a[i]);
	}
	for (int i = 0; i < n; i++)
	{
		printf("%s，", a[i]);
	}
	*/
	printf("\n");
//8
	/*
		结构体
		struct st {int a;char b[10];};
		struct tc {int a;char b[10];};

		struct st t1 = { 10,"xxxxx" };
		struct st t2=t1;
		t2 = t1;			相同名称的结构体可以直接赋值，但是不同名称的不可以，即使里面的类型一样也不可以
		struct tc t3=t1;	错误
		t3=t1;				错误
	*/
	return 0;
}
